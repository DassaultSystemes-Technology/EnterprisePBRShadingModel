<meta charset="utf-8">

    **Enterprise PBR Shading Model**
        Dassault Syst√®mes
        ![][license.png]
           Version 2022x

The Enterprise PBR Shading Model (DSPBR) is a high-quality, easy-to-use material optimized for performance in real-time and interactive scenarios, suitable for rasterization and ray tracing. Inspired by the Disney Principled BRDF [#Bur12, #Bur15] and the Unreal Shading Model [#Kar13], it combines a metallic and a dielectric BSDF, including transparency for thin-walled and volumetric objects. In addition, it provides effects like emission, clear coat, metallic flakes and sheen to cover a wide range of appearances.

In this document we provide a mathematical description of the Enterprise PBR Shading Model in terms of bidirectional scattering distribution functions (BSDF) and related concepts. Following the description makes it possible to derive a visually consistent implementation in a physically-based renderer.

Versions: [2019x](spec-2019x.md.html) [2021x](spec-2021x.md.html) 2022x

Components
==========

At its core, the Enterprise PBR Shading Model is a linear blend of a metallic BSDF and a dielectric BSDF, see Figure [components-diagram]. The dielectric BSDF can be either opaque or transparent. The former is used for materials like plastics, wood, or stone, and translucent materials like wax or skin. The latter makes the surface transparent, allowing light rays to refract into the object, resulting in attenuation and subsurface scattering. This is needed, for example, for glass, water, or ice. Section [Core] explains the BSDFs in more detail.

************************************************************************
* .-----------------------------------------------------------.        *
* |                          Clearcoat                        |        *
* '-----------------------------------------------------------'        *
*                                                                      *
* .----------------------------------------------. .----------.        *
* |                    Flakes                    | |          |        *
* '----------------------------------------------' |          |        *
*                                                  |          |        *
* .----------------------------------------------. |          |        *
* |                    Sheen                     | |          |        *
* '----------------------------------------------' |          |        *
*                                                  |          |        *
* .-------------+--------------------------------. |          |        *
* |  Metallic   |         Dielectric             | | Emission |        *
* |             |                                | |          |        *
* |             |   Opaque     |   Transparent   | |          |        *
* |             |              |                 | |          |        *
* |             |   - Plastic  |   - Glass       | |          |        *
* |             |   - Wood     |   - Water       | |          |        *
* |             |   - Stone    |   - Ice         | |          |        *
* |             |   - Wax      |                 | |          |        *
* |             |   - Plastic  |                 | |          |        *
* '-------------+--------------+-----------------+ '----------'        *
*                              |     Volume      |                     *
*                              '-----------------'                     *
************************************************************************
[Figure [components-diagram]: Structure of the Enterprise PBR Shading Model.]

The weights $m$ (metallic) and $t$ (transparency) control the blending between the BSDFs, as shown in Figure [blending-diagram] and described in Section [Putting it all together]. The values range from 0 to 1 and may vary based on the position on the surface.

*******************************
*               .---.         *
*              |  +  |        *
*               +---+         *
*          1-m /     \  m     *
*         .---+       \       *
*        |  +  |    Metallic  *
*         +---+               *
*    1-t /     \ t            *
*       /       \             *
*   Opaque    Transparent     *
* Dielectric  Dielectric      *
*******************************
[Figure [blending-diagram]: Blending of metallic and dielectric BSDFs based on parameters $m$ and $t$.]

On top of the core, a Fresnel-weighted specular BSDF adds coating effects, see Section [Clearcoat]. Moreover, the material can be configured to emit light via the emission component (Section [Emission]).

The material can operate in two modes: it can either simulate an infinitesimally thin, two-sided object or a volume boundary. Volume boundaries have to be attached to a closed mesh, i.e., the mesh encloses a volume and does not have any holes. The parameters of the volume extension (Section [Volume]) describe what happens inside the volume.

Core
----

The three BSDFs at the core of the Enterprise PBR Shading Model are built from a small number of building blocks, exploiting as many similarities as possible to reduce the mathematical complexity and, thus, computational effort. In the following, we first describe the individual BSDFs, then we show how to combine them efficiently, and finally we provide detailed equations for the distribution functions.

### Metallic BSDF

The metallic BSDF (Figure [bsdf-metallic]) is the combination of a microfacet BSDF $M_r$ and a configurable Fresnel term $F$, corrected for energy loss via the terms $M_{r,ms}$ and $F_{ms}$. Users can change the anisotropic roughness $r_u$, $r_v$ and the color at normal incidence $\rho$. The color at grazing angles is fixed to 1. Section [In-depth look at the BSDFs] describes the building blocks in more detail, for now we just show how they are combined and weighted.

\begin{equation}
\begin{aligned}
&\text{Metallic}(\mathbf{v}, \mathbf{l}; r_u, r_v, \rho) = \\
&\quad\quad\quad\quad
  \underbrace{M_r(\mathbf{v}, \mathbf{l}, \mathbf{h}_r; r_u, r_v)}_\text{Microfacet BRDF} \,
  \underbrace{F(\cos\theta_r; \rho, 1)}_\text{Fresnel} +
  \underbrace{M_{r,ms}(\mathbf{v}, \mathbf{l}; r_u, r_v)}_{\substack{\text{Multiple-scattering} \\ \text{compensation for } M_r}} \,
  \underbrace{F_{ms}(\rho, 1)}_{\substack{\text{Multiple-scattering} \\ \text{Fresnel}}}
\end{aligned}
\end{equation}

We parameterize the Fresnel $F(\cos\theta_r; f_0, f_{90})$ (Schlick approximation) by the angle $\theta_r$, the color at normal incidence $f_0$, and the color at grazing incidence $f_{90}$. By computing the angle $\theta_r$ from the half-vector $\mathbf{h}_r$, we take the orientation of the microfacets into account.

\begin{eqnarray}
\cos\theta_r &=& (\mathbf{h}_r \cdot \mathbf{v}) \\
\mathbf{h}_r &=& \frac{\mathbf{v} + \mathbf{l}}{\lVert\mathbf{v} + \mathbf{l}\rVert}
\end{eqnarray}

See Section [In-Depth Look at the BSDFs] for more details about the Fresnel term.

![Figure [bsdf-metallic]: The metallic BSDF is a single specular lobe.](img/bsdf_metallic.png)

### Dielectric BSDF for Transparent Surfaces

The Fresnel-weighted combination of a microfacet BRDF $M_r$ and a microfacet BTDF $M_t$ forms the BSDF for transparent dielectric surfaces like glass, oil, water, or air. As before, $r_u$ and $r_v$ change the anisotropic roughness of the BSDF. In addition, we now provide a parameter to change the index of refraction $\eta$, which determines how the light ray is refracted when entering the volume beneath the surface, and how the amount of incoming light is distributed to reflection and transmission. $s$ and $\rho_s$ allow fine-tuning the amount of reflection and its color. $\rho$ changes the color of the transmissive component. We again compensate for energy-loss of the reflection component via $M_{r,ms}$ and $F_{ms}$. Energy compensation for transmission may be added in a future revision.

The BSDF differs for thin-walled and volumetric materials. The volumetric case has to be enabled via a flag, see Section [Volume]. Figure [bsdf-transparent-dielectric] shows the two versions side-by-side. In the thin-walled case (left) the microfacet BTDF is identical to the microfacet BRDF, except that the lobe is mirrored onto the lower hemisphere. In the volumetric case (right) the transmissive lobe is bent according to the refraction angle computed from the index of refraction.

![Figure [bsdf-transparent-dielectric]: The dielectric BSDF for transparent surfaces is composed of a reflective lobe and a transmissive lobe. The material is configured (left) thin-walled or (right) volumetric. Note the different refraction angles.](img/bsdf_transparent_dielectric.png)

The thin-walled dielectric BSDF:

\begin{eqnarray}
\begin{aligned}
&\text{ThinTransparentDielectric}(\mathbf{v}, \mathbf{l}; r_u, r_v, \rho, s, \eta, \rho_s) = \\
&\quad\quad\quad\quad s \,
  \underbrace{M_r(\mathbf{v}, \mathbf{l}, \mathbf{h}_r; r_u, r_v)}_\text{Microfacet BRDF} \,
  \underbrace{F(\cos\theta_r; F_0 \rho_s, 1)}_\text{Fresnel} \\
&\quad\quad\quad + \rho\,
  \underbrace{{M_r}(\mathbf{v}, \mathbf{l}', \mathbf{h}_r'; r_u, r_v)}_{\substack{\text{Microfacet BTDF} \\ \text{(flipped BRDF)}}} \, (1 - s \, \underbrace{F(\cos\theta_r'; F_0 \rho_s, 1)}_\text{Fresnel}) \\
&\quad\quad\quad + s\,
  \underbrace{M_{r,ms}(\mathbf{v}, \mathbf{l}; r_u, r_v)}_{\substack{\text{Multiple-scattering} \\ \text{compensation for } M_r}} \,
  \underbrace{F_{ms}(F_0 \rho_s, 1)}_{\substack{\text{Multiple-scattering} \\ \text{Fresnel}}} \\
\end{aligned}
\end{eqnarray}

with

\begin{eqnarray}
{\mathbf{l}}^\prime &=& \mathbf{l} + 2 \mathbf{n} (-\mathbf{l} \cdot \mathbf{n})
\end{eqnarray}

to flip the light direction $\mathbf{l}$ from lower to upper hemisphere in case of thin transmission and

\begin{eqnarray}
\cos\theta_r &=& (\mathbf{v} \cdot \mathbf{h}_r) & \quad &
\cos\theta_r' &=& (\mathbf{v} \cdot \mathbf{h}_r') \\
\mathbf{h}_r &=& \frac{\mathbf{v} + \mathbf{l}}{\lVert\mathbf{v} + \mathbf{l}\rVert} & \quad &
\mathbf{h}_r' &=& \frac{\mathbf{v} + \mathbf{l}'}{\lVert\mathbf{v} + \mathbf{l}'\rVert}
\end{eqnarray}

to compute half vector and Fresnel angle based on the light direction. The Fresnel term at normal incidence depends on the index of refraction:

\begin{equation}
F_0 = \left(\frac{\eta_i - \eta_o}{\eta_i + \eta_o}\right)^2
\end{equation}

$\eta_i$ and $\eta_o$ determine the index of refraction of the current medium and the medium on the other side of the surface, respectively. They have to be setup properly by the renderer, taking into account the material's $\eta$.

The volumetric dielectric BSDF:

\begin{eqnarray}
\begin{aligned}
&\text{VolumetricTransparentDielectric}(\mathbf{v}, \mathbf{l}; r_u, r_v, \rho, s, \eta, \rho_s) = \\
&\quad\quad\quad\quad s \,
  \underbrace{M_r(\mathbf{v}, \mathbf{l}, \mathbf{h}_r; r_u, r_v)}_\text{Microfacet BRDF} \,
  \underbrace{F_d(\cos\theta_r; F_0 \rho_s, 1, \eta_i, \eta_o)}_\text{Fresnel (refractive version)} \\
&\quad\quad\quad + \rho\,
  \underbrace{{M_t}(\mathbf{v}, \mathbf{l}, \mathbf{h}_t; r_u, r_v, \eta_i, \eta_o)}_\text{Microfacet BTDF} \, (1 - s \, \underbrace{F_d(\cos\theta_t; F_0 \rho_s, 1, \eta_i, \eta_o)}_\text{Fresnel (refractive version)}) \\
&\quad\quad\quad + s\,
  \underbrace{M_{r,ms}(\mathbf{v}, \mathbf{l}; r_u, r_v)}_{\substack{\text{Multiple-scattering} \\ \text{compensation for } M_r}} \,
  \underbrace{F_{ms}(F_0 \rho_s, 1)}_{\substack{\text{Multiple-scattering} \\ \text{Fresnel}}} \\
\end{aligned}
\end{eqnarray}

with same reflection half vector and Fresnel angle as in the thin-walled case, but different calculation for transmission half vector and Fresnel angle:

\begin{equation}
\cos\theta_t = (\mathbf{v} \cdot \mathbf{h}_{t}) \\
\mathbf{h}_{t} = \frac{-\mathbf{v} \eta_i - \mathbf{l} \eta_o}{\lVert -\mathbf{v} \eta_i - \mathbf{l} \eta_o \rVert}
\end{equation}

Note that we now also use a different Fresnel term than in the thin-walled version. The Fresnel term $F_d$ takes total internal reflection into account.

### Dielectric BSDF for Opaque Surfaces

A lot of dielectric materials, like the majority of plastics, appear semi-transparent or opaque. This results from the strong subsurface scattering due to particles in the volume below the surface interacting with the transmitted light. A diffuse BRDF is a simple approximation for this effect. Consequently, we replace the BTDF introduced before by a diffuse-like BRDF (Figure [bsdf-opaque-dielectric]), resulting in a combination of a diffuse-like base BRDF $B$ and a Fresnel-weighted microfacet BRDF $M_r$. Parameter $\rho$ controls the color of $B$, all other parameters behave consistent to the transparent BSDF: The amount of specular contribution from the microfacet BRDF is determined by the parameters for specular tint $\rho_s$ and the index of refraction $\eta$, which both influence the Fresnel term. In addition, there is a directional-independent scaling factor $s$. $r_u$ and $r_v$ change the anisotropic roughness of the microfacet BRDF.

Paper, leaves of plants and other thin, dielectric objects transmit some of the incoming light into a random direction to the backside of the surface, the material looks translucent. Translucency is the physical property of a material which allows light to pass through, but not necessarily follow Snell's law on a macroscopic scale. A translucent material is made up of components with different indices of refraction. To achieve this effect, we provide the parameter $l$ that controls the blending between the diffuse BRDF and a diffuse BTDF. Besides thin objects, this can be useful for volumetric objects with subsurface scattering and short scattering distances. By scattering the light not only inside the volume, but also already when passing the interface, objects look more blurry and may converge much faster in a ray tracer.

As in the metallic BSDF, the energy loss of the microfacet term is compensated via $M_{r,ms}\,F_{ms}$.

The BSDF looks as follows:

\begin{equation}
\begin{aligned}
&\text{OpaqueDielectric}(\mathbf{v}, \mathbf{l}; r_u, r_v, \rho, s, \eta, \rho_s, l) = \\
&\quad\quad\quad\quad \rho \,
  \underbrace{B(\mathbf{v}, \mathbf{l}; r_u, r_v, l, s, F_0 \rho_s)}_\text{Diffuse-like base BRDF} \\
&\quad\quad\quad + s \, 
  \underbrace{M_r(\mathbf{v}, \mathbf{l}, \mathbf{h}_r; r_u, r_v)}_\text{Microfacet BRDF} \,
  \underbrace{F(\cos\theta_r; F_0 \rho_s, 1)}_\text{Fresnel} \\
&\quad\quad\quad + s \,
  \underbrace{M_{r,ms}(\mathbf{v}, \mathbf{l}; r_u, r_v)}_{\substack{\text{Multiple-scattering} \\ \text{compensation for } M_r}} \,
  \underbrace{F_{ms}(F_0 \rho_s, 1)}_{\substack{\text{Multiple-scattering} \\ \text{Fresnel}}}
\end{aligned}
\end{equation}

![Figure [bsdf-opaque-dielectric]: The dielectric BSDF for opaque ($l=0$, left) and translucent ($l=1$, right) surfaces is composed of a diffuse lobe and a specular lobe.](img/bsdf_opaque_dielectric.png)

Typically, the base BSDF $B$ is diffuse-like, reflecting the energy that is left after evaluating the microfacet layer equally in all directions. We follow the approach of [#KS01] and [#KC17] to measure the remaining energy and derive an energy-conserving and energy-preserving diffuse BRDF/BTDF out of it. Controlled by the parameter $s$ (i.e., the amount of specular contribution), we gradually blend between this new diffuse BSDF $B_c$ and the classic Lambertian BSDF $B_u$. The derivation of $B_c$ is explained in more detail in Section [In-depth look at the BSDFs] and Section [Energy Compensation].

\begin{equation}
B(\mathbf{v}, \mathbf{l}; r_u, r_v, l, s, f_0) = B_u(\mathbf{v}, \mathbf{l}; l) (1-s) + s B_c(\mathbf{v}, \mathbf{l}; r_u, r_v, l, f_0)
\end{equation}

### Putting It All Together

The core BSDF of the Enterprise PBR material is a linear combination of the metallic BSDF, the transparent dielectric BSDF and the opaque dielectric BSDF. The individual BSDFs are weighted by the material parameters $m$ (metallic) and $t$ (transparency).

\begin{eqnarray}
&\text{Core}(\rho, s, \eta, \rho_s) &=&\\
&&m           & \text{Metallic}(\rho) \nonumber\\
&+&(1-m)(1-t) & \text{OpaqueDielectric}(\rho, s, \eta, \rho_s) \nonumber\\
&+&(1-m)t     & \text{TransparentDielectric}(\rho, s, \eta, \rho_s) \nonumber
\end{eqnarray}

$\text{TransparentDielectric}$ is either the thin-walled BSDF $\text{ThinTransparentDielectric}$ or the volumetric BSDF $\text{VolumetricTransparentDielectric}$, depending on the corresponding material parameter (Section [Volume]).

Table [bsdf-terms] lists all the terms shared in the three BSDFs. In this and the following sections, we will define these terms. With the shared terms and parameters, we significantly reduce the amount of parameters of the complete material.

| Term | Description |
|-|-|
| $M_r(\mathbf{v}, \mathbf{l}, \mathbf{h}_r; r_u, r_v)$ | Microfacet BRDF for glossy and perfectly-specular reflection |
| $M_t(\mathbf{v}, \mathbf{l}, \mathbf{h}_t; r_u, r_v, \eta_i, \eta_o)$ | Microfacet BTDF for glossy and perfectly-specular transmission |
| $M_{r,ms}(\mathbf{v}, \mathbf{l}; r_u, r_v)$ | Multiple-scattering approximation for microfacet BRDF |
| $F(\cos\theta; f_0, f_{90})$ | Fresnel (reflection only) |
| $F_d(\cos\theta; f_0, f_{90}, \eta_i, \eta_o)$ | Fresnel (reflection and refractive transmission) |
| $F_{ms}(f_0, f_{90})$ | Multiple-scattering Fresnel (reflection only) |
| $B_u(\mathbf{v}, \mathbf{l}; l)$ | Lambertian reflection/translucency BSDF |
| $B_c(\mathbf{v}, \mathbf{l}; r_u, r_v, l, f_0)$ | Diffuse-like reflection/translucency BSDF simulating internal scattering layered beneath the microfacet BRDF |
[Table [bsdf-terms]: List of terms that are composed to form the core BSDF.]

Evaluating the complete material as sum of all BSDFs is expensive, as each BSDF contains a microfacet model and, therefore, we would have to compute the microfacet distribution multiple times. In order to avoid this overhead, we merge the microfacet models and put the weights $m$ and $t$ into the Fresnel term. This optimization is possible because we use Schlick's Fresnel approximation, see Section [In-Depth Look at the BSDFs].

In case the material is thin-walled, metallic and dielectric BSDFs use the same Fresnel term. The BSDF looks as follows, omitting some parameters for brevity. The complete derivation can be found in Section [Combining Metallic and Dielectric BSDFs].

\begin{equation}
\begin{aligned}
&\text{ThinCore}(\rho, s, \rho_s) = \\
&\quad\quad\quad\quad M_r \, F(\rho_{s,r,0}, \rho_{s,r,90}) \, \\
&\quad\quad\quad +M_{r,ms} \, F_{ms}(\rho_{s,r,0}, \rho_{s,r,90}) \\
&\quad\quad\quad +\rho_t {M_t}^\prime(1 - s F(F_0 \rho_s, 1)) \\
&\quad\quad\quad +\rho_d \left[B_u (1-s) + s B_c(F_0 \rho_s)\right]
\end{aligned}
\end{equation}

with

\begin{eqnarray}
\rho_{s,r,0} &=& (1-m) F_0 s \rho_s + m \rho \\
\rho_{s,r,90} &=& (1-m) s + m \\
\rho_t &=& \rho (1-m) t \\
\rho_d &=& \rho (1-m) (1-t)
\end{eqnarray}

If the material is volumetric, the dielectric Fresnel term handles refraction and total internal reflection. Therefore, we cannot simplify as much as before:

\begin{equation}
\begin{aligned}
&\text{VolumetricCore}(\rho, s, \eta, \rho_s) = \\
&\quad\quad\quad\quad M_r \, [\quad m \, F(\rho, 1) \\
&\quad\quad\quad\quad\quad\quad + (1-m) (1-t) s F(F_0 \rho_s, 1) \\
&\quad\quad\quad\quad\quad\quad + (1-m) t s F_d(F_0 \rho_s, 1)]\, \\
&\quad\quad\quad +M_{r,ms} \, F_{ms}(\rho_{s,r,0}, \rho_{s,r,90}) \\
&\quad\quad\quad +\rho_t M_t(1 - s F_d(F_0 \rho_s, 1)) \\
&\quad\quad\quad +\rho_d \left[B_u (1-s) + s B_c(F_0 \rho_s)\right]
\end{aligned}
\end{equation}

### In-Depth Look at the BSDFs

#### Tangent Space

We first need to define the tangent plane in which the BSDF calculations take place. The mesh data provides us with normal $\mathbf{n}$ and tangent $\mathbf{t}'$ in world space. The tangent must be aligned with the first axis ($u$ axis) of the texture coordinates on the mesh.

The anisotropic microfacet BSDFs are parameterized with roughness in tangent ($r_u$) and bitangent ($r_v$) directions. The two stretch the glossy BSDF lobe in the corresponding direction on the tangent plane. In addition the material provides the parameter anisotropy rotation $\beta$ that rotates the tangent plane and thus the glossy BSDF lobe. Given $\mathbf{n}$ and $\mathbf{t}'$, the rotated tangent vector $\mathbf{t}$ and bitangent vector $\mathbf{b}$ are calculated as follows:

\begin{eqnarray}
\mathbf{t} &=& \mathbf{t}' \cos\beta - (\mathbf{n} \times \mathbf{t}') \sin\beta \\
\mathbf{b} &=& \mathbf{n} \times \mathbf{t}
\end{eqnarray}

The bitangent $\mathbf{b}$ is aligned with the second axis ($v$ axis) of the texture coordinates on the mesh.

The parameterization of anisotropic roughness with $r_u$ and $r_v$ is inconvenient for users. In most cases users want to create isotropic materials. For this reason, we offer the material parameters isotropic roughness $r$ and anisotropy strength $o$ instead. As long as $o$ is kept at its default value of 0, the material is isotropic. Only in specific cases users may optionally add anisotropy by increasing $o$. $r_u$ and $r_v$ are calculated from $r$ and $o$ as follows:

\begin{equation}
\begin{pmatrix}r_u\\r_v\end{pmatrix} = r \begin{pmatrix}1\\1-o\end{pmatrix}
\end{equation}

Moreover, being an angle in range 0¬∞ to 360¬∞ makes $\beta$ difficult to use in textures. Therefore, we scale the range to $[0,1]$, with 0 corresponding to 0¬∞ and 1 corresponding to 360¬∞. The scaled aniostropy rotation parameter is called $b$. Please refer to Table [core-parameters] for an overview of all parameters and valid ranges offered by the core BSDF of the Enterprise PBR Shading Model.

#### Microfacet BSDF

Reflection and transmission are based on microfacet BSDFs [#Cook82, #WMLT07]. As in [#Bur12] we square the roughness $(r_u, r_v)$ to make it perceptually linear.

\begin{eqnarray}
M_r(\mathbf{v},\mathbf{l}, \mathbf{h}_r; r_u, r_v) &=& \frac{D(\mathbf{h}_r; r_u^2, r_v^2) G(\mathbf{v}, \mathbf{l}, \mathbf{h}_r; r_u^2, r_v^2)}{4 |\mathbf{v} \cdot \mathbf{n}| |\mathbf{l} \cdot \mathbf{n}|} \\
M_t(\mathbf{v},\mathbf{l}, \mathbf{h}_t; r_u, r_v, \eta_i, \eta_o) &=& \frac{|\mathbf{l} \cdot \mathbf{h}_t| |\mathbf{v} \cdot \mathbf{h}_t|}{|\mathbf{l} \cdot \mathbf{n}| |\mathbf{v} \cdot \mathbf{n}|} \frac{\eta_o^2 D(\mathbf{h}_t; r_u^2, r_v^2) G(\mathbf{v}, \mathbf{l}, \mathbf{h}_t; r_u^2, r_v^2)}{(\eta_i(\mathbf{v} \cdot \mathbf{h}_t) + \eta_o(\mathbf{l} \cdot \mathbf{h}_t))^2} \\
\end{eqnarray}

The BSDFs operate in the rotated local coordinate system (right-handed) defined by normal $\mathbf{n}$, tangent $\mathbf{t}$ and bitangent $\mathbf{b}$, see Figure [tangentspace]. We can convert between polar angle $\theta$, azimuthal angle $\phi$, and vectors as follows:

\begin{eqnarray}
\label{h_identities}
\mathbf{h} \cdot \mathbf{t} &=& \sin\theta_h \cos\phi_h \\
\mathbf{h} \cdot \mathbf{b} &=& \sin\theta_h \sin\phi_h \nonumber \\
\mathbf{h} \cdot \mathbf{n} &=& \cos\theta_h            \nonumber
\end{eqnarray}

The half vector $\mathbf{h}$ can be either the reflection half vector $\mathbf{h}_r$ or the transmission half vector $\mathbf{h}_t$.

![Figure [tangentspace]: Local coordinate system $(\mathbf{t}, \mathbf{b}, \mathbf{n})$ in which the BSDFs are evaluated and exemplary reflection half vector $\mathbf{h}_r$ with corresponding polar angle $\mathbf{\theta}_h$ and azimuthal angle $\mathbf{\phi}_h$.](img/tangentspace.png)

For the microfacet distribution, the material uses the Generalized Trowbridge-Reitz GTR model (generalized anisotropic GGX) [#Bur12] with $\gamma=2$. Using Equation [h_identities] we have

\begin{eqnarray}
D(\mathbf{h};\alpha_u,\alpha_v) &=& \frac{1}{\pi \alpha_u \alpha_v} \frac{\chi^+(\mathbf{h} \cdot \mathbf{n})}{\left(\frac{(\mathbf{h} \cdot \mathbf{t})^2}{\alpha_u^2}+\frac{(\mathbf{h} \cdot \mathbf{b})^2}{\alpha_v^2}+(\mathbf{h} \cdot \mathbf{n})^2\right)^2} \\
\chi^+(x) &=&
\begin{cases}
1\quad\text{if } x > 0 \\
0\quad\text{if } x \leq 0
\end{cases}
\end{eqnarray}

The appropriate Smith shadowing-masking term (height-correlated) [#Hei14] for GGX:

\begin{eqnarray}
G(\mathbf{v},\mathbf{l},\mathbf{h};\alpha_u,\alpha_v) &=& \frac{\chi^+(\mathbf{l} \cdot \mathbf{h}) \chi^+(\mathbf{v} \cdot \mathbf{h})}{1 + \Lambda(\mathbf{v}; \alpha_u, \alpha_v) + \Lambda(\mathbf{l}; \alpha_u, \alpha_v)} \\
\Lambda(\mathbf{x}; \alpha_u, \alpha_v) &=& \frac{-1 + \sqrt{1 + \frac{1}{a^2}}}{2} \\
\frac{1}{a^2} &=& \frac{1}{(\mathbf{x} \cdot \mathbf{n})^2} \left( (\mathbf{x} \cdot \mathbf{t})^2 \alpha_u^2 + (\mathbf{x} \cdot \mathbf{b})^2 \alpha_v^2 \right)
\end{eqnarray}

In the isotropic case ($\alpha = \alpha_u = \alpha_v$), the distribution simplifies to:

\begin{equation}
D(\mathbf{h};\alpha) = \frac{1}{\pi} \frac{\alpha^2}{((\mathbf{h} \cdot \mathbf{n})^2(\alpha^2-1)+1)^2}
\end{equation}

Correspondingly, $\frac{1}{a^2}$ in the shadowing-masking term simplifies to:

\begin{equation}
\frac{1}{a^2} = \alpha^2 \left( \frac{1}{(\mathbf{x} \cdot \mathbf{n})^2} - 1 \right)
\end{equation}

#### Fresnel

We use Schlick's Fresnel approximation for performance reasons (Section [Putting It All Together]). For thin-walled materials and the metallic BSDF we ignore refraction and total internal reflection, leading to a very simple form of the Fresnel term $F$. Taking both into account results in $F_d$, which is used for volumetric materials.

\begin{eqnarray}
F(\cos\theta; f_0, f_{90}) &=& f_0 + (f_{90} - f_0) (1 - |\cos\theta|)^5 \\
F_d(\cos\theta; f_0, f_{90}, \eta_i, \eta_o) &=& 
\begin{cases}
f_0 + (f_{90} - f_0) (1 - |\cos\theta|)^5 & \text{if } \eta_o \geq \eta_i \\
f_0 + (f_{90} - f_0) (1 - |\cos\theta_o|)^5 & \text{if } \eta_o < \eta_i \land \sin^2\theta_o < 1 \\
1 & \text{if } \eta_o < \eta_i \land \sin^2\theta_o \geq 1
\end{cases}
\end{eqnarray}

where $\theta_o$ is the angle of transmission, computed from the angle of incidence via $\sin^2\theta_o = \left(\frac{\eta_i}{\eta_o}\right)^2 (1 - \cos^2\theta)$ [#Lag13]. Note that in case of total internal reflection, the Fresnel does not depend on $f_{90}$ anymore, so it is impossible to disable the reflection in this situation. This allows users to change the specular component of a refractive object without introducing artifacts, i.e., dark appearance in areas where total internal reflection occurs.

#### Energy Preservation

The standard microfacet model does not account for scattering occuring between microfacets on the microsurface. As the surface becomes rougher, the multiple scattering becomes stronger, effectively resulting in high energy loss if this is not accounted for (see Figure [energycomp-microfacet-metallic]). [#KC17] describes a method based on [#KS01] to approximate multiple scattering for microfacet models that can be adapted for real-time rendering [#Fde19].

![Figure [energycomp-microfacet-metallic]: Left: Metallic surface with roughness 0. Middle: Non-energy preserving metallic surface with roughness 1. Right: Energy-preserving metallic surface with roughness 1 by accounting for multiple scattering. Note that the surface in the middle looks significantly darker than the others.](img/energycomp_metallic.png)

Following the approach of [#KS01] and [#KC17], we measure the directional albedo $E_m(\cos\theta; r_{uv})$ and average albedo $E_{m,avg}(r_{uv})$ by integrating the cosine-weighted single-scattering GGX microfacet model over all light directions. We precompute the integrals and store the result in lookup tables. In order to reduce the number of parameters, we replaced the anisotropic roughness $r_u$ and $r_v$ with an isotropic approximation $r_uv$.

Based on the measured albedo, we build an energy compensation term $M_{r,ms}(\mathbf{v},\mathbf{l}; r_u, r_v)\,F_{ms}(f_0, f_{90})$. The term is specifically tailored to $M_r$ and as such added in all places where $M_r$ is present.

\begin{equation}
\begin{aligned}
&M_{r,ms}(\mathbf{v},\mathbf{l}; r_u, r_v)\,F_{ms}(f_0, f_{90}) = \\
&\quad\quad\quad\underbrace{\frac{(1-E_m(\mathbf{v}\cdot\mathbf{n}; r_{uv}))(1-E_m(\mathbf{l}\cdot\mathbf{n}; r_{uv}))}{\pi(1-E_{m,avg}(r_{uv}))}}_{\text{Multiple-scattering GGX}} \underbrace{\frac{{F_{m,avg}}(f_0, f_{90})^2 E_{m,avg}(r_{uv})}{{1 - F_{m,avg}(f_0, f_{90})(1 - E_{m,avg}(r_{uv}))}}}_{\text{Multiple-scattering Fresnel}}
\end{aligned}
\end{equation}

with $r_{uv} = \sqrt{r_u r_v}$.

#### Diffuse BRDF

The Lambertian diffuse BRDF/BTDF $B_u(\mathbf{v}, \mathbf{l}; l)$ is described by the following equation:

\begin{equation}
B_u(\mathbf{v}, \mathbf{l}; l) = \frac{1}{\pi} T(\mathbf{v}, \mathbf{l}; l)
\end{equation}

with

\begin{equation}
T(\mathbf{v}, \mathbf{l}; l) = 
\begin{cases}
(1 - l) &\text{ if } (\mathbf{n} \cdot \mathbf{v}) (\mathbf{n} \cdot \mathbf{l}) > 0 \\
l &\text{ otherwise}
\end{cases}
\end{equation}

The term $(\mathbf{n} \cdot \mathbf{v}) (\mathbf{n} \cdot \mathbf{l})$ is positive if $\mathbf{v}$ and $\mathbf{l}$ point into the same hemisphere wrt. $\mathbf{n}$. This enables the diffuse reflection (BRDF). The term is negative if $\mathbf{v}$ and $\mathbf{l}$ point into opposite hemispheres wrt. $\mathbf{n}$. This enables the diffuse transmission/translucency (BTDF). The parameter $l$ determines the ratio between reflection and transmission.

As shown Section [Dielectric BSDF for Opaque Surfaces], $B_u$ is only used for the non-specular fraction of the dielectric BSDF. As soon as the microfacet BRDF $M_r$ blends in via $s$, we have to deduct its energy from the diffuse term.

Following the approach of [#KS01] and [#KC17], we measure the directional albedo $E(\cos\theta; r_{uv}, f_0)$ of the Fresnel-weighted microfacet GGX BRDF including the multi-scatter approximation. From this we build a complementary diffuse BRDF $B_c$ that, when added to $M_r$ and $M_{r,ms}$, results in an energy-conserving and energy-preserving total BRDF. Section [Diffuse BRDF] describes the process in more detail. As in Section [Energy Preservation], we use isotropic roughness $r_{uv} = \sqrt{r_u r_v}$.

\begin{eqnarray}
B_c(\mathbf{v}, \mathbf{l}; r_u, r_v, f_0) &=& \frac{(1-E(\mathbf{v}\cdot\mathbf{n}; r_{uv}, f_{0,\text{max}}))(1-E(\mathbf{l}\cdot\mathbf{n}; r_{uv}, f_{0,\text{max}}))}{\pi(1-E_{avg}(r_{uv}, f_{0,\text{max}}))} T(\mathbf{v}, \mathbf{l}; l)
\end{eqnarray}

We again use $T(\mathbf{v}, \mathbf{l}; l)$ to blend between diffuse reflection and transmission based on the translucency parameter $l$. $f_{0,\text{max}}$ denotes the maximum value of the wavelength-dependent color $f_0$ in linear sRGB,E color space. The maximum is used because the color is subtracted, leading to unexpected behavior if this is done per channel.

Directional albedo $E(\cos\theta; r_{uv}, f_0)$ and average albedo $E_{avg}(r_{uv}, f_0)$ are expensive to compute, as it involves integrating the Fresnel-weighted GGX microfacet BRDF over all light directions on the hemisphere. Therefore, we provide precomputed lookup tables for download in Section [Diffuse BRDF].

![Figure [energycomp-plastic]: Combination of diffuse and specular component with energy compensation for roughness 0 (left) and 1 (right). Note that the combination is energy-conserving (no energy is produced, even at multiple bounces inside the object) and energy-preserving (especially at grazing angles).](img/energycomp_plastic.png)

### Parameters

Table [core-parameters] describes the user parameters of the Enterprise PBR Shading Model. The parameters $s$, $m$ and $t$ make the model very flexible. Table [mst] shows a list of all available combinations and explains their meaning.

 Name        | Type          | Default | Range   | Description
-------------|---------------|---------|---------|-------------
$\mu$        | uniform bool  | true    |         | Material describes volume boundary (false) or thin, two-sided object (true).
$\rho$       | color         | 1       | [0,1]   | Albedo of the material.
$\rho_{s}$   | color         | 1       | [0,1]   | Specular tint to adjust the color of the specular lobe near $\theta=0^\circ$.
$m$          | float         | 0       | [0,1]   | Metallic-ness (0 = dielectric, 1 = metallic).
$s$          | float         | 1       | [0,1]   | Directional-independent amount of specular contribution to fine-tune the effect of the index of refraction.
$l$          | float         | 0       | [0,1]   | Translucency (0 = opaque, 1 = translucent).
$t$          | float         | 0       | [0,1]   | Transparency (0 = opaque, 1 = transparent).
$\eta$       | uniform float | 1.5     | [1,inf) | Index of refraction of the volume (t=1) or the dielectric coating (m=0).
$r$          | float         | 0       | [0,1]   | Roughness of microfacet distribution.
$o$          | float         | 0       | [0,1]   | Anisotropy strength.
$b$          | float         | 0       | [0,1]   | Anisotropy rotation angle (counter-clockwise rotation of the tangent space around local normal, where $0.25\equiv90^\circ$, $0.5\equiv180^\circ$, $1.0\equiv360^\circ$.
$\mathbf{n}$ | float3        | (0,0,1) | $\lVert\mathbf{n}\rVert=1$ | Normal for normal mapping.
[Table [core-parameters]: List of core parameters.]

![Figure [core-parameters-fig]: Examples for various values of core parameters.](img/params_core_2022x.png)

$m$ | $s$ | $t$ | Active Components | Use this for | Description
----|-----|-----|-------------------|--------------|-------------
0   | 0   | 0   | Diffuse | | Pure diffuse material.
0   | 0   | 1   | Refraction | | Pure refractive material.
0   | 1   | 0   | Diffuse, Reflection | Plastic, wood, stone | Specular coating on top of diffuse base layer. Adjust $\eta_o$ to change the index of refraction of the coating. For artistic effects, adjust $s$ and $\rho_s$ to fine-tune the coating layer.
0   | 1   | 1   | Reflection, Refraction | Glass, water, ice | Transparent material. Use $\eta_o$ to adjust the index of refraction. For artistic effects, adjust $s$ and $\rho_s$ to fine-tune the reflection.
1   | N/A | N/A | Reflection | Metal | Specular material with Fresnel effect that fades to white at grazing angles. Metallic takes precedence, $s$ and $t$ have no effect.
[Table [mst]: Metallic, Specular and Transparency.]

The basic workflow to configure a physically-plausible material involves three steps:

1. Choose the color $\rho$ of the material.
2. Choose the material type via $m$ and $t$.
3. Choose an IOR for the coating/refraction.

For more fine-grained artistic control, the material can now be tweaked even further:

4. Fine-tune amount of specular contribution via $s$.
5. Fine-tune specular color near $\theta=0^\circ$ via $\rho_s$.

Sheen
-----

For rendering cloth-like materials diffuse and specular BRDFs are not sufficient. Fibers standing perpendicular to the surface lead to backscattering, brightening the rims of objects. We simulate this effect with a microfacet-based sheen BRDF $M_b$, layered on top of the core described in Section [Core]. Its distribution with roughness $r_b$ generates micro-fiber normals, centered around grazing directions. The color is controlled via $\rho_b$. The BRDF and layering technique is taken from [#CK17].

 Name        | Type          | Default | Range  | Description
-------------|---------------|---------|--------|-------------
$\rho_b$     | color         | 0       | [0,1]  | Sheen color.
$r_b$        | float         | 0.3     | [0,1]  | Roughness of sheen microfacet distribution.
[Table [sheen-parameters]: List of sheen parameters.]

Sheen is layered on top of the core like a coating [#CK17]. Similar to the diffuse BRDF (Section [Diffuse BRDF]), we scale the bottom layer via the directional albedo of the top layer, resulting in an energy-conserving and (almost) energy-preserving mix of the BSDFs. The directional albedo of the sheen BRDF is fetched from a lookup table.

\begin{equation}
\begin{aligned}
&\text{ShinyCore}(\mathbf{v}, \mathbf{l}; \rho_b, r_b, \ldots) = \\
&\quad\quad\quad\quad \text{Core}(\mathbf{v}, \mathbf{l}; \ldots) \, \min(1 - \hat{\rho}_b E_b(\mathbf{v}\cdot\mathbf{n}; r_b), 1 - \hat{\rho}_b E_b(\mathbf{l}\cdot\mathbf{n}); r_b) \\
&\quad\quad\quad + M_b(\mathbf{v}, \mathbf{l}, \mathbf{h}_r; r_b) \, \rho_b
\end{aligned}
\end{equation}

As in Section [Diffuse BRDF], we subtract the maximum value $\hat{\rho_b} = \max{\rho_b}$ of the sheen color to avoid unexpected color shifts.

The sheen BRDF follows the usual microfacet equation. Note that the distribution roughness $\alpha_b$ is the squared sheen roughness: $\alpha_b = r_b^2$.

\begin{equation}
M_b(\mathbf{v}, \mathbf{l}, \mathbf{h}_r; r_b) = \frac{D_b(\mathbf{h}_r; r_b^2) G_b(\mathbf{v}, \mathbf{l}, \mathbf{h}_r;r_b^2)}{4 |\mathbf{v} \cdot \mathbf{n}| |\mathbf{l} \cdot \mathbf{n}|}
\end{equation}

The distribution of normals as given in [#CK17]:

\begin{eqnarray}
D_b(\mathbf{h}; \alpha_b) &=& \frac{(2+1/\alpha_b) \sin^{1/\alpha_b}\theta_b}{2\pi} \\
\sin\theta_b &=& \sqrt{1-(\textbf{h}\cdot\textbf{n})^2} \\
\end{eqnarray}

Since there is no easy analytical solution for the shadowing-masking term, [#CK17] compute the term numerically and use curve fitting. Although their fit is good, the error becomes quite noticable at small roughness values. The final sheen BRDF shows significant brightening at grazing angles in a white furnace test. For this reason we refined the fit to reduce the error, in particular near $\alpha_b = 0$. The key improvement is the new interpolation function for intermediate roughness values, which in our case is a bit more costly to compute.

\begin{eqnarray}
G_b(\mathbf{v},\mathbf{l},\mathbf{h}; \alpha_b) &=& \frac{\chi^+(\mathbf{l} \cdot \mathbf{h}) \chi^+(\mathbf{v} \cdot \mathbf{h})}{1+\Lambda(\mathbf{v}\cdot\mathbf{n}; \alpha_b)+\Lambda(\mathbf{l}\cdot\mathbf{n}; \alpha_b)} \\
\Lambda(\cos\theta; \alpha_b) &=& \begin{cases}
e^{L(|\cos\theta|; \alpha_b)} & \text{if } |\cos\theta|<0.5 \\
e^{2 L(0.5) - L(1 - |\cos\theta|; \alpha_b)} & \text{otherwise}
\end{cases} \\
L(x; \alpha_b) &=& \frac{a_0}{1 + a_1 x^{a_2}} + a_3 x + a_4
\end{eqnarray}

      |   $a_0$ |   $a_1$ |   $a_2$ |    $a_3$ |    $a_4$
------|---------|---------|---------|----------|----------
$p_0$ | 11.9095 | 4.68753 | 0.33467 | -2.22664 | -1.76591
$p_1$ | 13.7000 | 2.92754 | 0.28670 | -0.81757 | -1.22466
[Table [sheen-lambda-fit]: Values for $L(x; \alpha_b)$ used in $\Lambda$ curve fitting. Parameters are interpolated according to $\left(1.0 - w(\alpha_b)\right) p_1 + w(\alpha_b) p_0$.]

\begin{eqnarray}
w(\alpha_b) &=& \frac{c_0}{1 + c_1 {\alpha_b}^{c_2}} + c_3
\end{eqnarray}

   $c_0$ |   $c_1$ |    $c_2$ |   $c_3$
---------|---------|----------|---------
-1.59612 | 0.20375 | -0.55825 | 1.32805
[Table [sheen-lambda-fit-w]: Constants for $w(\alpha_b)$.]
 
If performance is a concern, due to the computation cost of the term above, we propose an alternative visibility term,
given in [#NP13]:

\begin{equation}
M_b(\mathbf{v}, \mathbf{l}, \mathbf{h}_r; r_b) = \frac{D_b(\mathbf{h}_r; r_b^2)}{4 ((\mathbf{v} \cdot \mathbf{n}) + (\mathbf{l} \cdot \mathbf{n}) - (\mathbf{v} \cdot \mathbf{n}) (\mathbf{l} \cdot \mathbf{n}))}
\end{equation}
The visual differences between the main model and the alternative model can be interactively observed on the following ShaderToy: https://www.shadertoy.com/view/wl3SWs.
![Figure [visu-main-sheen]: Main sheen model for growing roughness.](img/fabric_estevezkulla.png)
![Figure [visu-alt-sheen]: Alternative sheen model for growing roughness.](img/fabric_ashikhmin.png)
We can see through Figure [visu-main-sheen] and Figure [visu-alt-sheen] that consistency gets better as roughness grows. The alternative model is noticeably brighter for very low roughness values.
The directional albedo changes can be found in Section [Alternative Sheen BRDF]

Flakes
------

Some materials, such as car paint or grainy metals, exhibit shifting random patterns of bright sparkles or glints. These glints may suddenly appear or disappear if light or view direction changes. In car paints, for example, this phenomenon comes from small mirror-like flakes distributed in the material below its coating. This can be modeled with the flakes layer of the Enterprise PBR Shading Model.

### Parameters

 Name        | Type          | Default | Range  | Description
-------------|---------------|---------|--------|-------------
$f$          | float         | 0       | [0,1]  | Flake coverage (0 = no flakes, 1 = only flakes).
$\rho_f$     | color         | 1       | [0,1]  | Flake color.
$s_f$        | float         | 0       | [0,1]  | Flake size (diameter) in mm in world space.
$r_f$        | float         | 0       | [0,1]  | Roughness of distribution that controls flake orientation.
$f_f$        | float         | 0       | [0,1]  | Flip flop effect (0 = none, 1 = full).
$\rho_{ff}$  | color         | 1       | [0,1]  | Flake color at normal incidence if flip flop effect is enabled.
[Table [flakes-parameters]: List of flakes parameters]

![Figure [flakes-parameters-fig]: Result for various values of flakes parameters.](img/params_flakes_2022x.png)

Flake coverage $f$ determines the probability for a flake to be opaque. Flakes are layered on top of the sheen as seen on the Figure [components-diagram]. It's a boolean layering operation which either shows flakes or the underlying material depending on the transparency of individual flakes.

![Figure [flakes-coverage-fig]: Close-up look at effect of increasing flake coverage $f$: 0.0, 0.25, 0.5, 0.75, 1.0.](img/flakes_coverage_small.png)

Flake size $s_f$ chooses the average flake diameter in millimeters. Thus the conversion factor from scene unit to physical length unit must be known by the renderer in order to guarantee the correct appearance.

The total roughness $r_f$ is distributed mostly to the orientation roughness of the normals and to a smaller part to the cone angle of the cone BSDF used for the individual flakes (Equation [roughness-distribution]). To determine the distribution of flake orientations we sample from a GGX normal distribution function.

The flake color $\rho_f$ determines the color of the individual flakes. This is sufficient for a large variety of car paints. There are, however, some paints that exhibit strong directional-dependent color effects. These are often referred to as "flip flop effects" or "pearlescent paints". To mimic these effects, we provide an additional light-facing color $\rho_{ff}$ and an intensity parameter $f_f$.

### Layering

With flake opacity texture $o_{f}(\mathbf{p}; f, s_f)$, flake normal texture $\mathbf{n}_f(\mathbf{p}; f, s_f,r_f)$ and flake flip-flop color $c_f(\mathbf{v}, \mathbf{l}; \rho_f, f_f, \rho_{ff})$ the layers are combined as follows:

\begin{equation}
\begin{aligned}
&\text{GlitteryCore}(\mathbf{v}, \mathbf{l}; f, s_f, r_f, \rho_f, \ldots) = \\
&\quad\quad\quad\quad \text{ShinyCore}(\mathbf{v}, \mathbf{l}; \ldots) \, (1 - o_{f}(\mathbf{p}; f, s_f)) \\
&\quad\quad\quad + c_f(\mathbf{v}, \mathbf{l}; \rho_f, f_f, \rho_{ff}) B_f(\mathbf{v}, \mathbf{l}; r_f, \mathbf{n}_f) o_{f}(\mathbf{p}; f, s_f)
\end{aligned}
\end{equation}

Note that $\mathbf{p}$ is a shading point coordinate defined in object space.

### Flake Texture

Flake texture is fully procedural and is evaluated on the fly during shading. There are in fact 2 textures generated simultaneously: flake opacity texture $o_{f}(\mathbf{p}; f, s_f)$ and flake normal texture $n_f(\mathbf{p}; f, s_f,r_f)$. We procedurally generate the total number of flakes $N$ to be distributed over $1\text{m}^2$ texture space from the user-given flake size $s_f$. Flake texture is represented as a Voronoi diagram where individual flakes are represented as Voronoi cells.

\begin{eqnarray}
  r_\text{flake}  & = & \frac{1}{1000}\left(\frac{s_f}{2}\right) \qquad &\text{flake radius in m}\\
  A_\text{avgcell} & = & \frac{3\sqrt{3}}{2} r_\text{flake}^2 \qquad &\text{average hexagonal cell area in m}^2\\
  N & = & 1/A_\text{avgcell} \qquad &\text{number of Voronoi cells per m}^2\\
    & \approx & \frac{1.5396 \cdot 10^6}{s_f^2}
\end{eqnarray}

Now with the number of flakes $N$ in place we determine the resolution of a regular grid where each grid cell will be responsible for generating a fixed number $k$ of flakes.

\begin{eqnarray}
  \text{res} = \max\left(4,\left\lceil{ \sqrt{\frac{N}{k}} }\right\rceil \right)
\end{eqnarray}

We chose $k=4$ but this can be changed to optimize performance and/or for getting more randomness due to less stratified flake positions at higher $k$ (Section [Flake Consistency]).

Now that we have the resolution to house all $k\cdot \text{res}^2\approx N$ flakes, each grid cell needs to be able to be probed for its flakes. In order to do that each grid cell creates an initial seed value by inputting its integer coordinates
\begin{eqnarray}
  \label{grid-cell-coord}
  \begin{pmatrix}i \\ j\end{pmatrix} & = & \begin{pmatrix} \left\lfloor{ \text{res}\cdot \text{mod}(u,1) }\right\rfloor\\ \left\lfloor{ \text{res}\cdot \text{mod}(v,1) }\right\rfloor\end{pmatrix} \qquad \in \left[0, \text{res}-1\right]\times\left[0, \text{res}-1\right] \\
\end{eqnarray}
into a hash function. The hash is then used to seed an PRNG which is then used to produce all random numbers needed to produce the flake position, flake direction and opacity for each of the $k$ flakes in the grid cell.
Procedural normal map is mapped onto each object via triplanar mapping (Equation [tr-mapping]).
Triplanar mapping does surface parameterization based on a object space shading point $\mathbf{p}$ and bumped surface normal $\mathbf{n}$ simply by projecting it along the dominant orthogonal direction of $\mathbf{n}$ and returns parametric coordinates (u, v) on a surface.
\begin{eqnarray}
  \label{tr-mapping}
  T_\text{map}(p, n) =
  \begin{cases}
    (\text{frac}(+\text{sgn}(p_x) p_y + \frac{1}{2}), \text{frac}(p_z + \frac{1}{2})) & \text{if } |n_x|>|n_y| \land |n_x|>|n_z| \\
    (\text{frac}(-\text{sgn}(p_y) p_x + \frac{1}{2}), \text{frac}(p_z + \frac{1}{2})) & \text{if } |n_y|>|n_x| \land |n_y|>|n_z|\\
    (\text{frac}(+\text{sgn}(p_z) p_x + \frac{1}{2}), \text{frac}(p_y + \frac{1}{2})) & \text{otherwise}
  \end{cases}
\end{eqnarray}
Where sgn(x) and frac(x) are simple functions that return sign and fractional part of the floating point number. In order to find a flake under the shading point we go through following steps:

1. Determine (u, v) texture coordinates of the shading point using triplanar mapping (Equation [tr-mapping]).
2. Determine which flake grid cell it belongs (Equation [grid-cell-coord]).
3. Iterate over grid cells which can potentially contain closest flake.
4. Hash current grid cell coordinate and initialize PRNG seed with it.
5. Generate k number of flakes per cell, check and find the closest to (u, v).

Those steps are also shown in Listing [flakes].

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
(flake_position, flake_normal, flake_opaqueness) generate_flake(float r_f, float f, uint32 s) {
  (xi_1, xi_2) = prng(s);   //random numbers for flake position within the grid cell
  (xi_3, xi_4) = prng(s);   //random numbers for flake orientation
  xi_5 = prng(s);           //random number for flake transparency
  return ((xi_1, xi_2), K(r_f, xi_3, xi_4), O_f(f, xi_5));
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Flake generation for a (i, j) grid cell uses random number generator for generating 5 sequential random numbers for a single flake. As you can see we use first two random numbers from PRNG as a flake coordinate within the grid cell. For more information about PRNG please see section [Flake Consistency].

In order to generate flake normal we sample GGX normal distribution:

\begin{eqnarray}
  K(r_f, \xi_1, \xi_2) = \left(\sqrt{1 - w}\cos(2\pi\xi_2), \sqrt{1.0 - w}\sin(2\pi\xi_2), \sqrt{w}\right)
\end{eqnarray}

where ${w = \frac{1 - \xi_1}{1 - (1 - \alpha_\text{ggx}^2)\xi_1}}$. $\alpha_\text{ggx}$ which controls GGX distribution depends on a $r_f$ paramenter as well as BSDF cone angle $\alpha_\text{cone}$ (Equation [alpha-cone]). 

\begin{eqnarray}
  \label{roughness-distribution}
  \alpha_\text{ggx} = \sqrt{r_f^2 - \alpha_\text{cone}^2}
\end{eqnarray}

During flake generation we also call $O_{f}$ to get flake opaqueness. 
\begin{eqnarray}
  \label{flake-transparency}
  O_{f}(f, \xi) = 
  \begin{cases}
    \text{1} & \text{if } \xi < f\\
    \text{0} & \text{otherwise}
  \end{cases}
\end{eqnarray}

Based on a flake coverage and uniform random number unique per flake ${O_{f}(f, \xi)}$ returns 1 for opaque flakes and 0 for transparent ones.

We can now derive the textures $o_f(\mathbf{p}; f, s_f)$ and $\mathbf{n}_f(\mathbf{p}; f, s_f, r_f)$ as follows:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
(o_f, n_f) generate_textures(float3 p, float f, float s_f, float r_f) {
  //Determine (u, v) texture coordinates of the shading point using triplanar mapping
  uv = T_map(p, ...)
  
  //Determine which flake grid cell it belongs
  i, j = grid_cell(uv)

  //Iterate over grid cells which can potentially contain closest flake.
  for(ii=i-1; ii<=i+1; ii++) {
    for(jj=j-1; jj<=j+1; jj++) {
      //Hash current grid cell coordinate and initialize PRNG seed with it
      s = initPRNG(hash(ii, jj))
      nearest_d = inf
      //Generate k number of flakes per cell, check and find the closest to (u, v)
      for(fl=0; fl < k; fl++) {
        flake_pos, flake_normal, flake_opacity = generate_flake(f, r_f, s)
        voronoi_cell_d = length(uv-flake_pos);
        if(voronoi_cell_d < nearest_d) {
          nearest_o = flake_opacity
          nearest_n = flake_normal
        }
      }
    }
  }
  
  return nearest_o, nearest_n
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [flakes]: Sampling the procedural flake textures $o_{f}(\mathbf{p}; f, s_f)$ and $n_f(\mathbf{p}; f, s_f,r_f)$.]

### Flake BSDF

Generated flakes have a very simple BSDF. They behave like blurred mirrors, so they reflect light uniformly within a small cone aligned to a perfect reflection direction. Solid angle of the cone is defined as 
\begin{eqnarray}
  \Omega_{cone}(\cos\theta) = 2\pi(1-\cos\theta)
\end{eqnarray}

Taking it into account the flake BSDF looks like this : 
\begin{eqnarray}
  \label{flake-bsdf}
  B_f(\mathbf{v}, \mathbf{l}; r_f, \mathbf{n}_f) &=&
  \begin{cases}
    \frac{1}{\Omega_{cone}(\cos\theta_\text{cone})} & \text{if } (\mathbf{l} \cdot \mathbf{r}) > \cos\theta_\text{cone} \\
    0 & \text{otherwise}
  \end{cases}
\end{eqnarray}
with ${\mathbf{r}} = {2 \mathbf{n}_f (\mathbf{v} \cdot \mathbf{n}_f) - \mathbf{v}}$ , which is the reflection of the view vector $\mathbf{v}$ on the generated flake with a normal $\mathbf{n}_f$. $\theta_\text{cone}$ mentioned above is small to guarantee glittery  appearence of flakes and depends only on ${r_f}$ parameter. 

\begin{eqnarray}
  \cos\theta_\text{cone} = 1 - \frac{2 \alpha_\text{cone}^2}{1 + \alpha_\text{cone}^2}
\end{eqnarray}
\begin{eqnarray}
  \label{alpha-cone}
  \alpha_\text{cone}^2 = \min\left(\frac{\Omega_{cone}(\cos(\theta_\text{cone}^\prime))} {4\pi - \Omega_{cone}(\cos(\theta_\text{cone}^\prime))}, \frac{r_f^2}{2}\right)
\end{eqnarray}

where target cone angle ${\theta_\text{cone}^\prime = 7^\circ}$.

### Flip-Flop Effect

The flake BSDF is tinted with flake color $\rho_f$ and flip flop color $\rho_{ff}$. The two colors are mixed depending on the angle between view direction and flake normal. As the flakes itself are not perfectly specular, we take the reflection half-vector instead of the flake normal. This ensures that the BRDF is reciprocal.

The flip flop strength $f_f$ determines how much of the flip flop color is visible. A strength of 0 disables the effect.

The function $c_f$ that computes the angle-dependent flake tint is given as follows:

\begin{eqnarray}
  c_f(\mathbf{v}, \mathbf{l}; \rho_f, f_f, \rho_{ff}) &=& \rho_f + (\rho_{ff} - \rho_f) (\mathbf{v} \cdot \mathbf{h}_r)^\frac{1}{f_f^2} \\
  \mathbf{h}_r &=& \frac{\mathbf{v} + \mathbf{l}}{\lVert\mathbf{v} + \mathbf{l}\rVert} & \quad &
\end{eqnarray}

Instead of $(\mathbf{v}\cdot\mathbf{h}_r)$ renderers may also choose the dot product of view vector and surface normal $(\mathbf{v}\cdot\mathbf{n})$. This may give more accurate results with certain approximations like preconvolved IBL.

### Efficient Implementation

Rendering flakes is a challenging task for both offline and real-time renderers. While offline renderers solve pixel aliasing via Monte Carlo method, real-time renderers don't have computational budget high enough to afford that.
Calculating reflected light on a flaky surface is very hard when single pixel contains hundreds or thousands of flakes. In this case raw point based Monte Carlo method can cause extremely high variance and therefore suffer from an aliasing artifacts,
on the other hand none of the existing denoisers work well with flakes because it's hard to distinguish it from actual noise.
So it becomes necessary to do some type of filtering of the reflection, which will efficiently find most of the flakes under the pixel, which reflect light towards the viewer [#Jak14, #AK16].
Additional optimization can be done for a flaky surface seen from a large distance. When the number of flakes per pixel gets too high the reflection becomes smoother and therefore could be well approximated with Cook-Torrance reflection model with GGX distribution [#Cook82].

Clearcoat
---------

The clearcoat extension adds a dielectric coating as a layer on top of the core described in Section [Core]. $\text{GlitteryCore}(\mathbf{v},\mathbf{l})$ and coating are weighted with a Fresnel term. The parameter $c$ determines the strength of the effect.

\begin{equation}
\begin{aligned}
&\text{Coated}(\mathbf{v}, \mathbf{l}; c, r_c, \mathbf{n}_c, \ldots) = \\
&\quad \text{GlitteryCore}(\mathbf{v}, \mathbf{l}; \ldots) \,(1 - c \ \max(F_c(\mathbf{v} \cdot \mathbf{n}_c), F_c(\mathbf{l} \cdot \mathbf{n}_c)) \, \\
& +M_c(\mathbf{v},\mathbf{l},\mathbf{h}_r; r_c, \mathbf{n}_c) \, c \ F_c(\mathbf{h} \cdot \mathbf{v}) \, \\
\end{aligned}
\end{equation}

The coating is based on a microfacet BRDF with an isotropic GGX distribution and squared roughness. Distribution and shadowing-masking function are identical to the reflection component in the core material (Section [Microfacet BSDF]).

\begin{eqnarray}
M_c(\mathbf{v},\mathbf{l},\mathbf{h}_r; r_c) &=& \frac{D(\mathbf{h}_r;r_c^2,r_c^2) G(\mathbf{v},\mathbf{l},\mathbf{h}_r; r_c^2,r_c^2)}{4 |\mathbf{v} \cdot \mathbf{n}_c| |\mathbf{l} \cdot \mathbf{n}_c|}
\end{eqnarray}

The index of refraction in Schlick's Fresnel term is fixed to 1.5 to resemble a glass-like dielectric coating.

\begin{eqnarray}
F_c(\theta) &=& 0.04 + 0.96 \ (1 - \cos\theta)^5
\end{eqnarray}

As shown in Table [clearcoat-parameters], the clearcoat is parameterized via two scalar values and a normal.

 Name          | Type          | Default | Range  | Description
---------------|---------------|---------|--------|-------------
$c$            | float         | 0       | [0,1]  | Clearcoat reflectivity (0 = no clearcoat, 1 = full clearcoat).
$r_c$          | float         | 0       | [0,1]  | Roughness of clearcoat's microfacet distribution.
$\mathbf{n}_c$ | float3        | (0,0,1) | $\lVert\mathbf{n}_c\rVert=1$ | Clearcoat normal for normal mapping.
[Table [clearcoat-parameters]: List of clearcoat parameters.]

![Figure [clearcoat-parameters-fig]: Result for various values of clearcoat parameters.](img/params_clearcoat_2022x.png)

Cut-out
-------

The cut-out acts like an alpha channel for the surface. It makes parts of the surface transparent, independent of Fresnel terms, view and light direction or parameters.

 Name          | Type          | Default | Range  | Description
---------------|---------------|---------|--------|-------------
$\alpha$       | float         | 0       | [0,1]  | Cut-out opacity value (0 = transparent, 1 = opaque).
[Table [cutout-parameters]: List of cut-out parameters.]

![Figure [cutout-parameters-fig]: Result for various values of cut-out parameters.](img/params_cutout_2022x.png)

The cut-out parameter is primarily used in conjunction with textures to fake details in geometry, see Figure [cutout-geometry].

![Figure [cutout-geometry]: Cut-out texture applied to a sphere.](img/params_cutout_geometry_2022x.png)

Displacement
------------

Displacement mapping modifies the position $\mathbf{p}$ of surface points to add details to geometry. The displacement parameter $h$ is a vector, specifying the length and direction of the displacement in local surface coordinates defined by normal $\mathbf{n}$, tangent $\mathbf{x}$, and bitangent $\mathbf{y}$. The new position $\mathbf{p}^{\prime}$ is given as

\begin{eqnarray}
\mathbf{p}^{\prime} = \mathbf{p} + \mathbf{x} h_x + \mathbf{y} h_y + \mathbf{n} h_z
\end{eqnarray}

 Name          | Type          | Default | Range      | Description
---------------|---------------|---------|------------|-------------
$h$            | float3        | 0       | (-inf,inf) | Displacement in the direction of the surface normal.
[Table [displacement-parameters]: List of displacement parameters.]

Emission
--------

In addition to the reflective and transmissive components, the material contains an emissive component that turns surfaces into diffuse area lights. Light is emitted into the upper hemisphere with regard to the normal. The emission component is below the clearcoat in the layering stack, and thus it is scaled by clearcoat reflectivity $c$ and clearcoat Fresnel $F_c$, see Section [clearcoat].

\begin{eqnarray}
L_e(v) =
\begin{cases}
\rho_e \, (1 - c \, F_c(\mathbf{v} \cdot \mathbf{n}_c)) & \text{if } (\mathbf{v} \cdot \mathbf{n}) > 0 \\
0 & \text{otherwise}
\end{cases}
\end{eqnarray}

$\rho_e$ is luminance given in $\frac{\text{lm}}{\text{m}^2 \text{ sr}}$. It is computed from the parameters given in Table [emission-parameters].

 Name          | Type          | Default | Range   | Description
---------------|---------------|---------|---------|-------------
$l_c$          | color         | 1       | [0,inf) | Emission color.
$l_v$          | uniform float | 0       | [0,inf) | Emission value in $\text{lx}$ ($=\frac{\text{lm}}{\text{m}^2}$) (luminous emittance, the relative power leaving the object per surface area) or $\text{lm}$ (luminous power, the absolute power leaving the object). The parameter for unit selection may be called "emission mode".
$l_\text{norm}$| uniform bool  | false   |         | Normalize emission color.
[Table [emission-parameters]: List of emission parameters.]

![Figure [emission-parameters-fig]: Result for various values of emission parameters.](img/params_emission_2022x.png)

Lights are defined in photometric units. This means, the energy is spectrally weighted with the response curve of the human eye.

The emission is provided as color $l_c$ and energy value $l_v$. We expect the color to be in linear sRGB color space with a D65 whitepoint. If the energy normalization flag $l_\text{norm}$ is enabled, the color will be normalized by its luminance. This behavior is needed for physical workflows and it guarantees that the light exactly emits the specified value in its respective physical unit.

The following equations show how to compute $\rho_e$ from these parameters. $\text{area}$ denotes the area of the entire surface of an object in square meters.

\begin{eqnarray}
l = &
\begin{cases}
l_v l_c & \text{if } l_\text{norm}\text{ is false} \\
l_v \frac{l_c}{l_c \cdot \begin{pmatrix}0.2126729 \\ 0.7151522 \\ 0.0721750\end{pmatrix}} & \text{otherwise}
\end{cases} \\
\rho_e = &
\begin{cases}
\frac{1}{\pi \text{ area}} l & \text{if } l_v \text{ is given in lm} \\
\frac{1}{\pi} l & \text{if } l_v \text{ is given in } \frac{\text{lm}}{\text{m}^2}
\end{cases}
\end{eqnarray}

Volume
------

If the thin-walled material parameter is set to false, the surface to which the material is applied is treated as the volume boundary. Light rays falling to such a boundary may enter the volume, depending on the transparency or translucency of the surface's BSDF. Inside the volume light might be absorbed or scattered by particles, and eventually hit some surface from inside the volume. It can be a different surface and will most probably be a different point in space compared to the entrance point. At this exit point, if the material properties of the surface allow, light may leave the volume.

Absorption is controlled by the absorption coefficient $\sigma_a$; subsurface scattering by the scattering coefficient $\sigma_s$ and the phase function $p(\mathbf{v},\mathbf{l})$. The coefficients $\sigma_a$ and $\sigma_s$ are wavelength-dependent values in range $[0,\inf)$. Such an infinite range makes them hard to be controlled by the users.

To provide convenient parameterization for users we introduce three new user-friendly parameters: attenuation color $a$, attenuation distance $d$, and subsurface color $\rho_{ms}$. Attenuation color and distance are mapped to the attenuation coefficient $\sigma_t$ (or its inverse, the mean free path length $\text{mfp}$). Subsurface color is mapped to the single-scattering albedo $\rho_{ss}$ [#KC17].

\begin{eqnarray}
\sigma_t &=& \frac{1}{\text{mfp}} = \frac{-\log(a)}{d} \\
\rho_{ss} &=& 1 - \left(4.09712 + 4.20863\rho_{ms} - \sqrt{9.59217 + 41.6808\rho_{ms} + 17.7126\rho_{ms}^2}\right)^2
\end{eqnarray}

From this we derive the absorption and scattering coefficient.

\begin{eqnarray}
\sigma_a &=& \frac{1 - \rho_{ss}}{\text{mfp}} = \sigma_t (1 - \rho_{ss}) \\
\sigma_s &=& \frac{\rho_{ss}}{\text{mfp}} = \sigma_t\rho_{ss} = \sigma_t - \sigma_a
\end{eqnarray}

Intuitively, the mean free path length describes the reciprocal of the density of the medium. The denser the medium, the shorter the distance until a particle is hit and, therefore, the more light is absorbed or scattered out. In our case, after the light traveled $d$ units into the medium, all that remains is the color $a$.

When a particle is hit, the light color gets multiplied by the single-scattering color $\rho_{ss}$. On the surface, the color $\rho_{ms}$ can be observed from the multiple scattering events occurring in the medium.

In addition the phase function $p(\mathbf{v},\mathbf{l})$ determines the probability density of outgoing directions $\mathbf{l}$ given an incident direction $\mathbf{v}$ at a scattering event. We use the phase function developed by Henyey-Greenstein [#HG41]. It is controlled by a single parameter $g$ in the range $[-1,1]$, the *anisotropy parameter*.

\begin{eqnarray}
p(\mathbf{v},\mathbf{l}; g) = \frac{1}{4 \pi} \frac{1-g^2}{(1+g^2+2g(\mathbf{v} \cdot \mathbf{l}))^{3/2}}
\end{eqnarray}

Negative values of $g$ correspond to backward scattering and positive values to forward scattering. $g=0$ results in isotropic scattering.

 Name          | Type          | Default | Range   | Description
---------------|---------------|---------|---------|-------------
$a$            | uniform color | 1       | [0,1]   | Attenuation color.
$d$            | uniform float | inf     | [0,inf) | Attenuation distance. A value of 0 will make to surface opaque.
$\rho_{ms}$    | uniform color | 0       | [0,1]   | Subsurface color. Subsurface scattering is disabled if $\rho_{ms}=0$.
$g$            | uniform float | 0       | [-1,1]  | Subsurface anisotropy (<0:&#160;backward, =0:&#160;isotropic, >0:&#160;forward scattering).
[Table [volume-parameters]: List of volume parameters.]

![Figure [volume-parameters-fig]: Result for various values of volume parameters.](img/params_volume_2022x.png)

Dispersion
----------

In optics, dispersion is the phenomenon in which the index of refraction depends on the wavelength of the light. It is usually quantified by the Abbe number $\nu_d$. Typical values for the Abbe number range from 20 (flint glass) to 60 (crown glass). The larger the Abbe number, the weaker the effect.

![Figure [prism]: A dispersive prism breaks up white light into its spectral components (colors of the rainbow). This is the consequence of refraction angles varying with the wavelength of light rays.](img/prism.png)

The Abbe number $\nu_d$ is defined as

\begin{equation}
\nu_d = \frac{\eta_d - 1}{\eta_F - \eta_C},
\end{equation}

where $\eta_d$, $\eta_F$ and $\eta_C$ are the indices of refraction at the wavelengths corresponding to the Fraunhofer d, F and C lines:

\begin{eqnarray}
d &=& 587.56 \text{ nm} \\
F &=& 486.13 \text{ nm} \\
C &=& 656.27 \text{ nm}
\end{eqnarray}

For rendering, we need a function that maps from any wavelength to an index of refraction, given the material's index of refraction $\eta_d$ and Abbe number $\nu_d$. One such mapping is Cauchy's equation. In its most general form, the equation is

\begin{equation}
\eta(\lambda) = a + \frac{b}{\lambda^2} + \frac{c}{\lambda^4} + ...,
\end{equation}

where $\lambda$ is the wavelength and $a$, $b$, $c$, ... are coefficients obtained by fitting measured data. Usually, its sufficient to use the first two coefficients. We can compute those from the two given values $\eta_d$ and $\nu_d$ as follows:

\begin{eqnarray}
b &=& \frac{\eta_d-1}{\nu_d} \frac{1}{\frac{1}{F^2} - \frac{1}{C^2}} \\
a &=& \eta_d - \frac{b}{d^2}
\end{eqnarray}

Thus Cauchy's equation based on the Abbe number is (with symbolic constants replaced by their actual value):

\begin{equation}
\eta(\lambda) = \max(\eta_d + \frac{\eta_d-1}{\nu_d} \left( \frac{523655}{\lambda^2} - 1.5168 \right), 1)
\end{equation}

$\eta_d$ in this equation has to be set to the original value of the user-facing parameter for index of refraction $\eta$. The result $\eta(\lambda)$ then replaces the parameter's value. As a special case we disable dispersion if Abbe number $\nu_d = 0$.

 Name    | Type          | Default | Range   | Description
---------|---------------|---------|---------|-------------
$\nu_d$  | uniform float | 0       | [0,inf) | Abbe number. Dispersion effect is disabled if $\nu_d = 0$.

Material Parameters
===================

All information about parameter ordering and grouping, names, types, ranges, default values etc. required for a UI can be found in [params-2022x.json](params-2022x.json). Application developers should follow these recommendations so that the UI is consistent across applications. The file format is documented in the appendix, Section [Parameter JSON file format]. You can use the [Javascript-based viewer application](param-viewer.html) to inspect the JSON file.

Material Subtypes
=================

The Enterprise PBR Shading Model offers a limited but still substantial amount of parameters. For easier usability, especially for novice users, we recommend to use the following subtypes, which expose only subsets of parameters:

* Car Paint
* Metal
* Emissive
* Textile
* Leather
* Wood
* Glass
* Plastic

For compatibility with the widely spread Unreal model [#Kar13], additionally a general purpose material called "Basic" is recommended.

In addition to the parameters of the Enterprise PBR Shading Model (Section [Material Parameters]), the JSON file [params-2022x.json](params-2022x.json) documents parameters and default values for the subtypes. The file format is documented in the appendix, Section [Parameter JSON file format]. You can use the [Javascript-based viewer application](param-viewer.html) to inspect the JSON file.

Design Rationale
================

The Enterprise PBR Shading Model is the basis for a large variety of use-cases, ranging from high-performance VR applications to high-quality offline GI renderings. However, it is not expected that it will cover all use-cases one can imagine, but it should be sufficient for day-to-day use. This requires some tradeoffs, which are based on the following guidelines and requirements.

Most important, the material should be *easy to use* for inexperienced users, but still powerful enough for trained artists in real-time rendering and global illumination. For this reason, the material has only a small amount parameters, following industry-standard workflows known from real-time engines (Unreal Engine 4, Unity Engine) and movie production (Disney BRDF). Using the *metallic/roughness workflow*, it is possible to create a wide varietey of materials from just a very small subset of the whole parameter set, namely albedo, metallic, roughness and normal map. Another aspect of this is the fact that it allows users to parameterize materials in a way that they are *physically-based as a default*, but can be tweaked when needed for more artistic freedom, for example via the specular tint and specular parameters. Wherever possible, the parameters are linear and texturable, so that *layering via parameter blending* is possible. Notable exceptions are parameters affecting the volume, because there are no texture coordinates available inside an object.

Especially for GI renderers, there are certain physical and mathematical properties that materials or BSDFs must fullfill. A BSDF must obey *Helmholtz reciprocity* (for bidirectional rendering methods), be *positive* and *energy conserving* (for fast convergence).

*Performance in real-time rendering* is a critical aspect. Most parameters do not influence each other or have a clearly defined state in which an effect is disabled, making it possible to specialize shader code for certain use-cases. Clearly, offline GI rendering also profits from this, but besides that it is also important to choose BSDFs that can be *sampled efficiently*, like the GGX microfacet model.

As many software packages offer a unified interface to different renderers, *consistency across renderers* and rendering-algorithms is another key requirement for the material. A material prepared in one renderer, for example in GI, should look the same in other renderers, for example in a rasterizer. As this is not always possible, because some effects like refraction or brute-force subsurface scattering are impossible in a real-time rasterizer, the *rasterizers will approximate* the *ground-truth GI solution*. The material is defined in a way that it encourages approximations wherever possible.

Not all real-world effects can be rendered with the Enterprise PBR Shading Model. Especially for high-quality renderings or light simulation, artists and engineers need more flexbility. Other material systems like [Open Shading Language (OSL)](https://github.com/imageworks/OpenShadingLanguage) from Imageworks or [Material Definition Language (MDL)](http://mdlhandbook.com/) from NVIDIA allow users to build their own materials from basic building blocks structured as a node graph. The [Appearance Exchange Format (AxF)](https://www.xrite.com/axf) from X-Rite stores results from a capturing process using their material scanners. Such material systems and models are projected onto the parameters of the Enterprise PBR Shading Model via *fitting* (or *distilling*).

Changelog
=========

Version 2022x
-------------

* Added material subtype for Leather and changed defaults of Textile, Basic (anisotropy is now hidden) and CarPaint (flake color).
* Specified displacement, translucency and subsurface anisotropy parameters for material subtypes.
* Removed sheen parameter.
* Sheen roughness is now squared.
* Improved sheen shadowing-masking term.
* Added flip-flop effect to flakes.
* Added dispersion.

Version 2021x
-------------

* Displacement mapping.
* Translucency.
* New sheen effect based on "Charlie" Sheen BRDF, layered on top of core material via albedo-scaling [#CK17].
* Alternative visibility term for "Charlie" Sheen BRDF [#NP13].
* Emission is now below clearcoat in the layering stack.
* Henyey-Greenstein phase function for volume scattering [#HG41].
* Flakes layer.

Version 2019x
-------------

* Initial version.

Appendix
========

Combining Metallic and Dielectric BSDFs
---------------------------------------

The core of the Enterprise PBR Material is a weighted sum of three BSDFs, the metallic BSDF, the opaque and the transparent dielectric BSDF. The similarity between the BSDFs allows us to simplify the material significantly. We start from the sum of the three BSDFs:

\begin{eqnarray}
&\text{ThinCore}(\rho, s, \eta, \rho_s) &=&\\
&&m           & \text{Metallic}(\rho) \nonumber\\
&+&(1-m)(1-t) & \text{OpaqueDielectric}(\rho, s, \eta, \rho_s) \nonumber\\
&+&(1-m)t     & \text{ThinTransparentDielectric}(\rho, s, \eta, \rho_s) \nonumber
\end{eqnarray}

Note that we omitted some parameters here to make the equations shorter. These do not influence the weighting.

\begin{eqnarray}
\text{ThinCore}(\rho, s, \eta, \rho_s) &=& \text{ThinCore}(\mathbf{v}, \mathbf{l}; r_u, r_v, \rho, s, \eta, \rho_s, l) \\
\text{Metallic}(\rho) &=& \text{Metallic}(\mathbf{v}, \mathbf{l}; r_u, r_v, \rho) \\
\text{OpaqueDielectric}(\rho, s, \eta, \rho_s) &=& \text{OpaqueDielectric}(\mathbf{v}, \mathbf{l}; r_u, r_v, \rho, s, \eta, \rho_s, l) \\
\text{ThinTransparentDielectric}(\rho, s, \eta, \rho_s) &=& \text{ThinTransparentDielectric}(\mathbf{v}, \mathbf{l}; r_u, r_v, \rho, s, \eta, \rho_s)
\end{eqnarray}

Substituting all terms leads to

\begin{eqnarray}
&\text{ThinCore}(\rho, s, \eta, \rho_s) &=& \\
&&m           & M_r \, F(\cos\theta_r; \rho, 1) \nonumber\\
&+&m          & M_{r,ms} \, F_{ms}(\rho, 1) \nonumber\\
&+&(1-m)(1-t) & \rho \, B(\mathbf{v}, \mathbf{l}; s, F_0, \rho_s) \nonumber\\
&+&(1-m)(1-t) & s\,M_r \, F(\cos\theta_r; F_0 \rho_s, 1) \nonumber\\
&+&(1-m)(1-t) & s\,M_{r,ms} \, F_{ms}(F_0 \rho_s, 1) \nonumber\\
&+&(1-m)t     & s \, M_r \, F(\cos\theta_r; F_0 \rho_s, 1) \nonumber\\
&+&(1-m)t     & \rho\,{M_r}^\prime \, (1 - s \, F(\cos\theta_r'; F_0 \rho_s, 1)) \nonumber\\
&+&(1-m)t     & s\,M_{r,ms} \, F_{ms}(F_0 \rho_s, 1) \nonumber \\
\end{eqnarray}

and after rearranging we get

\begin{eqnarray}
&=&& M_r \left[
        m \, F(\cos\theta_r; \rho, 1) +
        (1-m) (1-t) s \,F(\cos\theta_r; F_0 \rho_s, 1) +
        (1-m) t s \, F(\cos\theta_r; F_0 \rho_s, 1)
    \right] \nonumber\\
&&+& M_{r,ms} \left[
        m \, F_{ms}(\rho, 1) +
        (1-m) (1-t) s \, F_{ms}(F_0 \rho_s, 1) +
        (1-m) t s F_{ms}(F_0 \rho_s, 1)
    \right] \nonumber\\
&&+& (1-m)t \rho\,{M_r}^\prime \, (1 - s \, F(\cos\theta_r'; F_0 \rho_s, 1)) \nonumber\\
&&+& (1-m)(1-t) \rho \, B(\mathbf{v}, \mathbf{l}; s, F_0, \rho_s)
\end{eqnarray}

With the Schlick approximation for the Fresnel term

\begin{equation}
F(\cos\theta,f_0,f_{90}) = f_0 + (f_{90} - f_0) (1 - \cos\theta)^5
\end{equation}

the following properties hold

\begin{eqnarray}
a \, F(\cos\theta,f_0,f_{90}) &=& F(\cos\theta, a \, f_0, a \, f_{90}) \\
F(\cos\theta, a, b) + F(\cos\theta, c, d) &=& F(\cos\theta, a+c, b+d)
\end{eqnarray}

Approximately, that is also the case for the multi-scattering Fresnel $F_{ms}$, so we assume

\begin{eqnarray}
a \, F_{ms}(f_0,f_{90}) &\approx& F_{ms}( a \, f_0, a \, f_{90}) \\
F_{ms}(a, b) + F_{ms}(c, d) &\approx& F_{ms}(a+c, b+d)
\end{eqnarray}

This allows us to simplify the combined BSDFs and we arrive at the final form:

\begin{eqnarray}
\text{ThinCore}(\rho, s, \eta, \rho_s)&=&& M_r F(\cos\theta_r; (1-m) s F_0 \rho_s + m \rho, (1-m)s + m) \nonumber\\
&&+& M_{r,ms} F_{ms}((1-m) s F_0 \rho_s + m \rho, (1-m)s + m)) \nonumber\\
&&+& (1-m)t \rho\,{M_r}^\prime \, (1 - s \, F(\cos\theta_r'; F_0 \rho_s, 1)) \nonumber\\
&&+& (1-m)(1-t) \rho \, B(\mathbf{v}, \mathbf{l}; s, F_0, \rho_s)
\end{eqnarray}


Energy Compensation
-------------------

### Multiple-Scattering GGX BRDFs

The GGX microfacet BRDF $M_r(\mathbf{v},\mathbf{l}; r_u, r_v)$ only models a single scattering event, which is the first reflection that occurs at a facet on the microsurface. Multiple bounces between the facets are ignored, effectively leading to too much absorption in the model. [#KC17] describes a method to approximate the missing contribution from multiple scattering. It requires directional and average albedo of the single-scattering model. We precompute those values and store them in a lookup table. In this section we describe how the precomputation step works.

In [#KC17], the missing energy due to the missing multiple-scattering in the GGX microfacet model $M_r$ is approximated by adding an additional compensation term $M_{r,ms}$. We will call the sum $F_{r, 1}$:

\begin{eqnarray}
F_{r, 1}(\mathbf{v},\mathbf{l}; r_u, r_v) &=& M_r(\mathbf{v},\mathbf{l}; r_u, r_v) + M_{r,ms}(\mathbf{v},\mathbf{l}; r_u, r_v) \\
&=& M_r(\mathbf{v},\mathbf{l}; r_u, r_v) + \frac{(1 - E_m(\mathbf{v}\cdot\mathbf{n}; r_{uv}))(1 - E_m(\mathbf{l}\cdot\mathbf{n}; r_{uv}))}{\pi (1 - E_{m,avg}(r_{uv}))}
\end{eqnarray}

We use this sum in all core BSDFs of our model. For now, however, we have omitted the Fresnel term, because at first we are only interested in a surface that is 100% reflective. $E_m$ and $E_{m,avg}$ denote the directional albedo and average albedo respectively. To keep it simple we replaced the anisotropic roughness $r_u, r_v$ with an isotropic approximation $r_{uv} = \sqrt{r_u r_v}$. This means that in the end our multiple-scattering term slightly underestimates the real contribution, but this is not a huge issue in typical scenes.

First we compute the directional albedo $E_m$.

\begin{eqnarray}
E_m(\mathbf{v}; r_{uv}) &=& \int_{\Omega_\mathbf{l}} M_r(\mathbf{v}, \mathbf{l}, \mathbf{h}_r; r_{uv}) (\mathbf{l} \cdot \mathbf{n}) \, \mathrm d \mathbf{l} \\
\implies E_m(\theta_v, \phi_v; r_{uv}) &=& \int_{0}^{2\pi} \int_{0}^{\frac{\pi}{2}} M_r(\theta_l, \phi_l, \theta_v, \phi_v; r_{uv}) \cos \theta_l \sin \theta_l \, \mathrm d \theta_l \, \mathrm d \phi_l
\end{eqnarray}

We are only interested in the difference between $\phi_l$ and $\phi_v$, because rotating the BRDF does not change the result. Therefore, with $\phi=\phi_l - \phi_v$ and $\phi_v = 0$ ($\implies \mathrm d \phi = \mathrm d \phi_l$) we get

\begin{eqnarray}
E_m(\theta_v; r_{uv}) &=& \int_{0}^{2\pi} \int_{0}^{\frac{\pi}{2}} M_r(\theta_l, \phi, \theta_o; r_{uv}) \cos \theta_l \sin \theta_l \, \mathrm d \theta_l \, \mathrm d \phi
\end{eqnarray}

By reparameterization with $\mu_{\{l,v\}} = \cos \theta_{\{l,v\}}$ ($\implies \mathrm d \mu_{\{l,v\}} = -\sin \theta_{\{l,v\}} \, \mathrm d \theta_{\{l,v\}}$), we arrive at the simpler form

\begin{eqnarray}
E_m(\mu_v; r_{uv}) = \int_{0}^{2\pi} \int_{0}^{1} M_r(\mu_l, \phi, \mu_v; r_{uv})  \, \mu_l \, \mathrm d \mu_l \, \mathrm d \phi \\
\end{eqnarray}

Evaluating this integral for different values of $\mu_v$ and isotropic roughness $r$ results in the image shown in Figure [energy-compensation-ggx-e].

![Figure [energy-compensation-ggx-e]: Directional albedo of single-scattering microfacet GGX BRDF.](img/energycomp_ggx_e.png)

Integrating over the hemisphere once more gives us the average albedo (Figure [energy-compensation-ggx-e-avg]):

\begin{eqnarray}
E_{m, avg}(r_{uv}) &=& 2 \int_0^1 E_{m}(\mu_v; r_{uv}) \mu_v \, \mathrm d \mu_v
\end{eqnarray}

![Figure [energy-compensation-ggx-e-avg]: Average albedo of single-scattering microfacet GGX BRDF.](img/energycomp_ggx_e_avg.png)

We are now able to store these results in a lookup table (e.g., with a size of 32x32 pixels) and fetch them during the evaluation of the BSDF to compute the energy compensation term $M_{r,ms}$.

So far, we ignored the Fresnel term. But similar to scaling the single-scattering microfacet term with a single-scattering Fresnel term, we need to scale the multiple-scattering compensation term with the average Fresnel. This is the average Schlick Fresnel:

\begin{eqnarray}
F_{m,avg}(f_0, f_{90}) &=& \frac{1}{21} f_{90} + \frac{20}{21} f_0
\end{eqnarray}

Results from the white furnace test are shown in Figure [energycomp_none-ggx], Figure [energycomp_fit-ggx] and Figure [energycomp_lut-ggx]. While there is still a bit of energy loss when using the fitted function, the sphere becomes almost invisible when using the more accurate data from the 32x32 table.

![Figure [energycomp_none-ggx]: White furnace test without energy compensation for $r=\{0.1, 0.6, 0.9\}$.](img/energycomp_none-ggx.png)

![Figure [energycomp_lut-ggx]: White furnace test with energy compensation.](img/energycomp_lut-ggx.png)

We provide the lookup tables for download in our Github repository:
* [res/GGX_E.exr](https://github.com/DassaultSystemes-Technology/EnterprisePBRShadingModel/tree/master/res/GGX_E.exr): $E_m(\cos\theta; r_{uv})$, $x$: $\cos\theta$, $y$: $r_{uv}$.
* [res/GGX_E_avg.exr](https://github.com/DassaultSystemes-Technology/EnterprisePBRShadingModel/tree/master/res/GGX_E_avg.exr): $E_{m,avg}(r_{uv})$, $x$: $\cos\theta$.

### Diffuse BRDF

The incident illumination that hits an object will either be reflected at the surface or enter it and be scattered equally in all directions. The latter results in a diffuse look that is modeled with the diffuse component $B$. The ratio between specular and diffuse reflection is determined by the Fresnel term.

For an energy-preserving and energy-conserving combination of the components we apply the same ideas as for the GGX energy compensation described in Section [Multiple-Scattering GGX BRDFs]. We measure how much energy is left after evaluating the Fresnel-weighted multiple-scattering GGX BRDF and scale the diffuse BRDF accordingly.

First we compute the directional albedo of the multiple-scattering GGX including the Fresnel term:

\begin{equation}
\begin{aligned}
E(\mu_v; r_{uv}, f_0) =& \int_{0}^{2\pi} \int_{0}^{1} M_r(\mu_l, \phi, \mu_v; r_{uv}) F(\mu_l; f_0, 1) \\
&\quad\quad\quad\quad+ M_{r,ms}(\mu_l, \phi, \mu_v) F_{ms}(f_0, 1) \, \mu_l \, \mathrm d \mu_l \, \mathrm d \phi
\end{aligned}
\end{equation}

This results in a 3D lookup table, see Figure [energy-compensation-base-e]. As the function is smooth, a resolution of 16 pixels in each dimension is sufficient.

![Figure [energy-compensation-base-e]: Directional albedo of Fresnel-weighted multi-scattering microfacet GGX BRDF for different values of $f_0$.](img/energycomp_base_e.png)

As before, we integrate over the hemisphere once more to get average albedo

\begin{eqnarray}
E_{avg}(r_{uv}, f_0) &=& 2 \int_0^1 E(\mu_v; r_{uv}, f_0) \mu_v \, \mathrm d \mu_v
\end{eqnarray}

and store the result of the integration in a table with 16x16 pixels (Figure [energy-compensation-base-e-avg]).

![Figure [energy-compensation-base-e-avg]: Average albedo of Fresnel-weighted multi-scattering microfacet GGX BRDF for different values of $f_0$.](img/energycomp_base_e_avg.png)

![Figure [energycomp_lut-base]: White furnace test for combination of diffuse and specular component.](img/energycomp_lut-base.png)

We provide the lookup tables for download in our Github repository:
* [res/Base_*_E.exr](https://github.com/DassaultSystemes-Technology/EnterprisePBRShadingModel/tree/master/res/): $E(\cos\theta; r_{uv}, f_0)$, $x$: $\cos\theta$, $y$: $r_{uv}$, filename: $f_0$
* [res/Base_E_avg.exr](https://github.com/DassaultSystemes-Technology/EnterprisePBRShadingModel/tree/master/res/Base_E_avg.exr): $E_{avg}(r_{uv}, f_0)$, $x$: $r_{uv}$, $y$: $f_0$

### Sheen BRDF

We use the albedo-scaling technique described in [#KS01] and [#CK17] to layer the sheen BRDF on top of the core material. As the technique supports arbitrary BSDFs as base layer, it does not depend on the parameters of the core material.

As before, we precompute the directional albedo of the sheen BRDF (Equation [sheen-brdf-directional-albedo]). This results in a 16x16 2D lookup table (Figure [energy-compensation-sheen-e]).

\begin{equation}
\label{sheen-brdf-directional-albedo}
E_b(\mu_v; r_b) = \int_{0}^{2\pi} \int_{0}^{1} M_b(\mu_l, \phi, \mu_v; r_b) \, \mu_l \, \mathrm d \mu_l \, \mathrm d \phi
\end{equation}

![Figure [energy-compensation-sheen-e]: Directional albedo of the sheen BRDF. The y-axis is the squared sheen roughness $\alpha_b = r_b^2$.](img/energycomp_sheen_e.png)

We provide the lookup table for download in our Github repository:
* [res/Sheen_E.exr](https://github.com/DassaultSystemes-Technology/EnterprisePBRShadingModel/tree/master/res/Sheen_E.exr): $E_b(\cos\theta; r_b)$, $x$: $\cos\theta$, $y$: $\alpha_b = r_b^2$

### Alternative Sheen BRDF

We precompute the directional albedo of the alternative sheen BRDF using Equation [sheen-brdf-directional-albedo] (Figure [energy-compensation-sheen-ash-e]).

![Figure [energy-compensation-sheen-ash-e]: Directional albedo of the alternative sheen BRDF. The y-axis is the squared sheen roughness $\alpha_b = r_b^2$.](img/energycomp_sheen_ash_e.png)

![Figure [white-furnace-sheen-ash-e]: White furnace test of alternative sheen BRDF with roughness from 0 to 1, left to right. Red pixels indicate energy gain.](img/furnace_ashikhmin.png)

The lookup table is also provided for download in our Github repository:
* [res/Sheen_ash_E.exr](https://github.com/DassaultSystemes-Technology/EnterprisePBRShadingModel/tree/master/res/Sheen_ash_E.exr): $E_b^\text{ash}(\cos\theta; r_b)$, $x$: $\cos\theta$, $y$: $\alpha_b = r_b^2$

## Flake Consistency

You might have noticed that we do not define hashing function and PRNG used for generating flakes. This limits consistency of flakes between different renderers because different random number generators will produce different flake position, orientation values for grid cells, but gives you opportunity to try out different ones depending on your needs. From our experience, this can significantly affect shading performance. Additionally number of flakes per grid cell is also something you can experiment with. For cheaper hashing functions it's beneficial to have low number of flakes per grid cell like 1 or 2.

## Parameter JSON file format

We provide a JSON file containing a machine-readable list of all user-facing parameters of the Enterprise PBR Shading Model and its subtypes: [params-2022x.json](params-2022x.json).

In addition, there is a [Javascript-based viewer application](param-viewer.html) to inspect the file.

### Format

The JSON file contains multiple materials under the root node called `materials`. A material has a unique identifier and a set of properties describing its display name, preview image, and parameters.

```json
{
  "materials": {
    "generic": {
      "name": "Enterprise PBR Shading Model",
      "preview": "previewImage.png",
      "parameters": {
        ...
      }
    }
  }
}
```

Parameters have a unique identifier, a display name, a type, type-specific defaults and ranges, and properties to describe optimal placement in the UI.

```json
{
  "materials": {
    "generic": {
      ...
      "parameters": {
        "albedo": {
          "name": "Albedo",
          "type": "color",
          "max": [1, 1, 1],
          "default": [1, 1, 1],
          "uiOrder": 0,
          "group": "Base"
        },
        "metallic": {
          "name": "Metallic",
          "type": "float",
          "min": 0,
          "max": 1,
          "default": 0,
          "uiOrder": 1,
          "group": "Base"
        },
        "ior": {
          "name": "Index of Refraction",
          "type": float,
          "uniform": true,
          "uiOrder": 28,
          "group": "Volume",
          ...
        }
        ...
      }
    }
  }
}
```

The properties `uiOrder` and `group` specify the order and group in which the parameters should be displayed in the user interface. The empty group `''` must be displayed before any other named group. In addition, the Boolean property `hidden` (not shown in the example) controls the visibility of a parameter in the UI. This is useful in conjunction with inheritance and will be explained later in Section [Inheritance].

### Types

Table [json-types] lists the supported parameter types.

 Type | Default | Min | Max | Description 
------|---------|-----|-----|--------------------------------
 `float` | 0 | <nobr>-inf</nobr> | <nobr>+inf</nobr> | Floating-point number.
 `color` | [0, 0, 0] | [0, 0, 0] | [inf, inf, inf] | Color in linear sRGB, given as an array of 3 numbers.
 `normal` | [0, 0, 1] | n/a | n/a| Unit-length 3D normal vector, given as an array of 3 numbers.
 `vector` | [0, 0, 0] | [<nobr>-inf</nobr>, <nobr>-inf</nobr>, <nobr>-inf</nobr>] | [<nobr>+inf</nobr>, <nobr>+inf</nobr>, <nobr>+inf</nobr>] | 3D Vector, given as an array of 3 numbers.
 `boolean` | false | n/a | n/a | Boolean value, `true` or `false`.
 `enum` | n/a | n/a | n/a | Enumeration, valid values are given in an array called `enum`. Example: `{ "type" : "enum", "enum": ["apples", "oranges"], "default": "apples" }`.
[Table [json-types]: List of parameter types supported in the JSON file.]

The properties `min`, `max`, and `default` are optional. If not set, the values are derived from the type.

Since JSON does not define the value `inf`, the following object can be used instead of a floating-point number to indicate `+inf`: `{ "infinity": true }`.

A parameter type can be marked as uniform with the `uniform` property. If unset the parameter is not uniform.

### Inheritance

Materials can derive from other materials via the `inherits` property. Inheriting from a material means to recursively merge the properties from the derived material into the base material. Derived properties overwrite base properties. Example:

```json
{
  "materials": {
    "dielectric": {
      "name": "Dielectric",
      "parameters": {
        "ior": {
          "type": "float",
          "default": 1.5
        },
        "transparency": {
          "type": "float",
          "default": 0
        }
      },
    },
    "glass": {
      "inherits": "dielectric",
      "name": "Glass",
      "parameters": {
        "ior": {
          "default": 1.52
        },
        "transparency": {
          "default": 1,
          "hidden": true
        }
      }
    }
  }
}
```

We derive a new material `glass` from the base material `dielectric`. The `glass` material changes the default `ior` from 1.5 to 1.52 and the default `transparency` from 0 to 1. In addition, we hide the `transparency` parameter from the user by specifying `{ "hidden": true }`. Note that by default all parameters of the base material are visible in the derived material. Use the `hidden` property to make them invisible in derived materials.

Bibliography
============

[#Bur12]: Brent Burley. Physically-Based Shading at Disney, SIGGRAPH 2012.

[#Bur15]: Brent Burley. Extending the Disney BRDF to a BSDF with Integrated Subsurface Scattering., SIGGRAPH 2015.

[#CK17]: Alejandro Conty Estevez, Christopher Kulla. Production Friendly Microfacet Sheen BRDF, SIGGRAPH 2017.

[#Fde19]: Carmelo J. Fdez-Ag√ºera. A Multiple-Scattering Microfacet Model for Real-Time Image-based Lighting., Journal of Computer Graphics Techniques Vol. 8, No. 1, 2019.

[#Hei14]: Eric Heitz. Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs., Journal of Computer Graphics Techniques Vol. 3, No. 2, 2014.

[#HG41]: Louis G. Henyey and Jesse L. Greenstein. Diffuse radiation in the galaxy. Astrophysical Journal 93, 70‚Äì83, 1941.

[#Hil18]: Stephen Hill. A Multi-Faceted Exploration, 2018. https://blog.selfshadow.com/2018/05/13/multi-faceted-part-1/

[#Kar13]: Brian Karis. Real Shading in Unreal Engine 4., SIGGRAPH 2013.

[#KC17]: Christopher Kulla, Alejandro Conty. Revisiting Physically Based Shading at Imageworks. 2017.

[#Jak14]: Wenzel Jakob et al. Discrete Stochastic Microfacet Models, ACM Transactions on Graphics (ACM SIGGRAPH 2014).

[#AK16]: Asen Atanasov and Vladimir Koylazov. A Practical Stochastic Algorithm for Rendering Mirror-Like Flakes. 2016.

[#KS01]: Csaba Keleman, Lazlo Szirmay-Kalos. A Microfacet Based Coupled Specular-Matte BRDF Model with Importance Sampling, Eurographics 2001.

[#Lag13]: S√©bastien Lagarde. Memo on Fresnel equations, 2013. https://seblagarde.wordpress.com/2013/04/29/memo-on-fresnel-equations/

[#WMLT07]: Bruce Walter, Stephen R. Marschner, Hongsong Li, Kenneth E. Torrance. Microfacet models for refraction through rough surfaces., EGSR 2007.

[#NP13]: David Neubelt and Matt Pettineo. Crafting a Next-Gen Material Pipeline for The Order: 1886. 2013.

[#Cook82]: Robert L. Cook, Kenneth E. Torrance. 1982. A Reflectance Model for Computer Graphics.

License
=======

The Enterprise PBR Shading Model (DSPBR), ¬© Dassault Syst√®mes 2021, is licensed under [CC-BY-SA 4.0](http://creativecommons.org/licenses/by-sa/4.0/). In addition, please acknowledge your use of the Dassault Syst√®mes Enterprise PBR Shading Model (DSPBR) when DSPBR is used or implemented in a product by adding  the following "[name of the product] is implementing DSPBR, the Dassault Syst√®mes Enterprise PBR Shading Model", in a place and format which shall be reasonably visible.

![](https://i.creativecommons.org/l/by-sa/4.0/88x31.png)

[license.png]: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPCAMAAABEF7i9AAAAllBMVEUAAAD///+rsapERER3d3eIiIjMzMzu7u4iIiKUmZO6v7rKzsoODg4RERFVVVUNDQ0NDg0PEA8zMzNLTEtbXltmZmZydnF9gn2AgICPkI+ZmZmqqqq7u7vFxsXIzMgNDQwZGRkgICAhISEkJSMnKCcuMC4xMzE5Ozk7PTtBQkFCQkJDQ0Nna2eGhoaHh4ezuLLGysbd3d1wVGpAAAAA0klEQVR42q2T1xbCIAyGk0CXdlmto3XvPd7/5QRL1432WHI4XED4+PMHALQHag0JJBlXMNQScx2ibu9PdTnQcY3iErYl6oxbAo/rUrUJA6J5vx0wNNC0gVkMbBPZXtQ8Uf6qpNJwOf0EjmCKto+ce1aSIg9FzTO1/xlYyVeL34FDMC3ZFT+SNXOX6PEsBKm0rIOYPYuGClnsWTxBHtQV1gRhI4UUGJh6EAsPoxdedjUPK+dzT38DDyvNXXYW9wJ43mh4h6ItN8U7Ldv+FN1/WXO8Aed5CQIgC4KiAAAAAElFTkSuQmCC

<!-- Markdeep: --><style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style><script src="https://casual-effects.com/markdeep/1.12/markdeep.min.js" charset="utf-8"></script><script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>
